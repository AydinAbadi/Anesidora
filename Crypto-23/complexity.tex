% !TEX root =U-PSI.tex
\section{Complexity Analysis}
\vspace{-2mm}
\subsection{Computation Complexity} \label{compcomp}

We first analyse the computation cost of U-PSI when the clients delegate PSI to the cloud. In our analysis, we do not count the pseudorandom function invocation cost, as it is a fast operation, and dominated by the other operations (e.g. modular arithmetic, shuffling and factorization). In step d.\ref{shuffleB}, client $B$ executes $h$ modular additions, and  shuffles a vector of $h$ elements with a cost of $O(c)$. Also, it performs  $nh$ modular additions in each of steps d.\ref{blindshuffleB} and f.\ref{unblind} to  blind and unblind  the hash table elements,  respectively. In step f.\ref{interpolate} it interpolates $h$ polynomials with each interpolation costing $O(d)$, where $d$ is a constant value. In step f.\ref{factorize}, it factorizes $h$ polynomials with each factorization costing $O(d^{\scriptscriptstyle 2})$. So in total client $B$'s computation cost is $(4+5d+d^{\scriptscriptstyle 2})h$ which is $O(c)$. Client $A$ in step  d.\ref{RegenKeys}  shuffles a vector of $h$ elements that costs $O(h)$ and in  step d.\ref{cleintAshuffles} it does $h$ modular additions, and shuffles a vector of $h$ elements. In step d.\ref{shuffleA}, it performs $2hnd$ modular multiplications and $2hnd$ modular additions to evaluate the pseudorandom polynomials. In the same step, to generate vectors $\vv{\bm{v}}^{\scriptscriptstyle (A)}$ and $\vv{\bm{v}}^{\scriptscriptstyle (B)}$, it performs $2nh$ modular multiplications. In step d.\ref{vectorq}, it permutes two vectors of  $h$ elements and carries out $2nh$ modular additions to generate  vectors $\vv{\bm{q}_{\scriptscriptstyle e}}$. Thus, in total it performs $(9+12d+8d^{\scriptscriptstyle 2})h$ or $O(c)$ modular operations. The cloud in step e.\ref{cloudcomp} performs  $2hnd$ modular multiplications and $2hnd$ modular additions to evaluate the pseudorandom polynomials. In the same step, it performs $2nh$ modular multiplications and $3nh$ modular additions to generate the vectors $\vv{\bm{t}_{\scriptscriptstyle e}}$. Thus, in total the cloud's computation involves $(5+14d+8d^{\scriptscriptstyle 2})h$ or  $O(c)$ modular operations. 
%In our multi-client protocol, the  computation complexity for those clients who authorise the computation,  is similar  to the  two-client protocol's, also the complexity for the cloud and result recipient would be $O(c\textsl{m-2c} )$, where $\textsl{m}$ is the total number of clients. 

In the update phase, each client  carries out $2d+2$ modular additions in step c.\ref{unblindupdate}. It interpolates a polynomial in step c.\ref{interpolateupdate} which costs $O(d)$.  In step c.\ref{InsertionDeletion}, it executes $d$ modular additions and $d$ modular multiplications to evaluate the polynomial at the single value $s$. In the same step, when the update is element insertion, the client extracts a bin's set elements that costs $O(d^{\scriptscriptstyle 2})$, and carries out $nd$ modular multiplications and $nd$ modular additions to evaluate the polynomial. So, the total computation cost for insertion is $5d(1+d)$, or $O(1)$ as $d$ is constant. If the update is element deletion, the client performs $2n$ modular additions to evaluate the two polynomials and $2n$ modular multiplications to generate  pseudorandom values. Finally, in step c.\ref{freshfactors}, the client performs $n+1$ modular additions. Therefore, the client's total computation cost for deletion is $6d+4$ or $O(1)$. 

In \cite{opsi15,DBLP:conf/fc/AbadiTD16,yang2018improved} set elements are represented as a single polynomial whose degree is linear to the set cardinality, $c$. In these protocols, the cost  of computing PSI is dominated by public key encryption operations, with complexity $O(c)$, and  polynomial factorization, with complexity $O(c^{\scriptscriptstyle 2})$. To insert/delete an element in  \cite{opsi15,yang2018improved}, a client needs to encode the element to be inserted/deleted as a polynomial, evaluate the polynomial on $2c+1$ elements and perform $2c+1$ modular multiplications, to blind the evaluated values. Also, the cloud needs to perform the same number of multiplications to apply the update. Therefore, the protocols' update complexity is $O(c)$. However, in \cite{DBLP:conf/fc/AbadiTD16} due to the way each outsourced value is blinded, the client has to download the entire date, remove the blinding factors and apply the change locally that also costs it $O(c)$. The protocol in \cite{eopsi} uses a hash table and encodes  set elements into a set of polynomials of constant degree, and this leads to $O(c)$ for computing PSI. In this protocol, if a client naively updates only one bin, then the cloud would be able to learn which elements have been updated with a non-negligible probability. The reason is that the bins are in their original order, and each bin's address is the hash value of an element in the bin, so if the client retrieves one bin, then the cloud would be able to figure out  what element is being updated  with a non-negligible probability when the set universe is not big. So, for the client to securely update its data, it has to re-encode the entire outsourced data that costs $O(c)$ too. 

Thus, the PSI computation cost in \cite{opsi15,DBLP:conf/fc/AbadiTD16,yang2018improved} is $O(c^{\scriptscriptstyle 2})$ while in our protocol and in \cite{eopsi} it is  $O(c)$. Moreover, update phase has $O(c)$ complexity in  \cite{opsi15,DBLP:conf/fc/AbadiTD16,yang2018improved,eopsi} while it has  much less cost, i.e. $O(1)$, in our protocol. 

\vspace{-3mm}

\subsection{Communication Complexity} \label{commcomp}

In U-PSI for PSI delegation client $B$, in step d.\ref{whatBSends}, sends a single value $tk^{\scriptscriptstyle (B)}$ to the cloud. In this step, it sends two  values, $pk^{\scriptscriptstyle (B)}$ and $lk^{\scriptscriptstyle (B)}$, and vector $\vv{\bm{r}}^{\scriptscriptstyle (B)}$ of $h$ bins to client $A$. Therefore, client $B$'s communication cost is $h(2d+1)+3$ or $O(c)$. In step d.\ref{WhatclientAsends}, client $A$ sends $tk^{\scriptscriptstyle (A)}$ and vector $\pi(pk^{\scriptscriptstyle (A)},\vv{\bm{m}}_{\scriptscriptstyle A \rightarrow B})$ containing $2h$ elements to the cloud. In the same step, it sends vector $\vv{\bm{q}}$ containing $h$ bins to client $B$. So, client $A$'s total communication cost  is $h(3+2d)+1$ or $O(c)$. The cloud's communication cost is $h(2d+1)$ or $O(c)$, as in step e.\ref{EO-cloudRes}, it sends vector $\vv{\bm{t}}$ of $h$ bins to client $B$. 
%Moreover, in our multi-client protocol, the communication cost of the cloud and the clients who authorize the computation remains the same as that of in two-client case, i.e. $O(c)$, but the result recipient' communication cost is $O(c\textsl{m}-c )$. 
To update its outsourced set a client sends to the cloud two labels, one in each of steps c.\ref{firstupdatestep} and c.\ref{lastupdatestep}. Moreover, it sends a vector of $2d+1$ elements in step c.\ref{lastupdatestep}. So, in total its communication cost is $3+2d$ or $O(1)$. Also, the cloud in step c.\ref{firstupdatestep} sends a vector of $2d+1$ elements to the client. Therefore,  the cloud's communication cost is $2d+1$ or $O(1)$. Note that  every message in our protocol is a random element of a finite field.

% Note that in our scheme for a fixed probability of overflow and fixed bin maximum load, the hash table length $h$ is linear to the set cardinality $c=\frac{c'}{m}$ (see section \ref{balls-bins}). 

%The reason is that if we rewrite $d=(1+\sigma)\cdot \frac{c}{h}$ (presented in subsection \ref{balls-bins}) we would have $h=(1+\sigma)\cdot \frac{c}{d}$.  

Both the PSI computation and update phases in the protocols in \cite{opsi15,yang2018improved,DBLP:conf/fc/AbadiTD16} have  $O(c)$ communication complexity.  Note that each message in these protocols for PSI computation is a ciphertext of a public key encryption and its size is  much larger  than the size of a field element, but the messages sent for an update is a field element. The protocol in \cite{eopsi} has $O(c)$ communication complexity for PSI computation, and as a client needs to re-encode the entire dataset to securely update it, it requires sending $h(2d+1)$, or $O(c)$ elements of a finite field.  

%As we stated earlier in section \ref{U-PSIdiscussion}, in O-PSI protocol, in order for a client to  update the data it needs to download them,  update locally, and upload them to the cloud, so its update cost is $O(c)$. Also, in EO-PSI, if  client  simply updates one bin it would leak non-negligible information about  set elements to the cloud (see section \ref{U-PSIdiscussion} for discussion). So,  in EO-PSI, the  secure way for the client to update the outsourced dataset is to retrieve the entire dataset and update it locally and send it back to the cloud.  However, such approach imposes $O(hd)$ communication cost. On the other hand, the protocol in \cite{Lopez-Alt12} that utilizes FHE can support data update  by using the FHE's capabilities. But, the protocol is designed for generic computation and the complexity of update in delegated PSI has not been defined. Note that each message in EO-PSI and U-PSI protocols is a random element of a   field (e.g. $p$ is about $112$ bits), whereas the messages in the other two protocols are ciphertexts of public key encryption that operate in a much larger group/ring. 

Hence,  our protocol and those in \cite{opsi15,DBLP:conf/fc/AbadiTD16,yang2018improved} have $O(c)$ communication complexity for PSI computation, but for updates only in U-PSI the client can securely update its dataset with $O(1)$ communication cost, while this cost is $O(c)$  for the other three protocols.