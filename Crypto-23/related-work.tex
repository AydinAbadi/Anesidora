% !TEX root =main.tex

\vs

\section{Related Work}\label{sec::related-work}


Since their introduction in \cite{DBLP:conf/eurocrypt/FreedmanNP04}, various PSIs have been designed. PSIs can be divided into \textit{traditional} and \textit{delegated} ones.   
%
In \textit{traditional} PSIs, data owners interactively compute the result using their local data. 
%
Very recently, Raghuraman and Rindal \cite{RaghuramanR22} proposed two two-party PSIs, one secure against semi-honest/passive and the other against malicious/active adversaries. To date, these two protocols are the fastest two-party PSIs. They rely on  Oblivious Key-Value Stores (OKVS)  and Vector Oblivious Linear Evaluation. Their  computation cost is $O(c)$, where $c$ is  a set's cardinality.  They impose $O(c\log c^{\st 2}+\kappa)$ and $O(c\cdot \kappa)$ communication costs in the semi-honest and malicious security models respectively, where $l$ is a set element's bit-size and  $\kappa$ is a security parameter.  
%
Also, researchers designed PSIs that let multiple (i.e., more than two) parties efficiently compute the intersection. The multi-party PSIs in  \cite{DBLP:conf/scn/InbarOP18,DBLP:conf/ccs/KolesnikovMPRT17} are secure against  passive adversaries while those in \cite{Ben-EfraimNOP21,GhoshN19,ZhangLLJL19,DBLP:conf/ccs/KolesnikovMPRT17,NevoTY21} were designed to remain secure against  active ones.  To date, the  protocols  in   \cite{DBLP:conf/ccs/KolesnikovMPRT17} and  \cite{NevoTY21} are the most  efficient multi-party PSIs  designed to be  secure against passive and active  adversaries respectively. The two remain secure even if the majority of parties are corrupt.  
%
%The PSIs in  \cite{DBLP:conf/ccs/KolesnikovMPRT17,NevoTY21} to keep the overall costs low and avoid requiring all clients to interact with each other in all steps of the protocols, use a ``leader'' client which interacts with the rest of the clients. 
%
The former relies on symmetric key primitives such as  Programmable Pseudorandom Function (OPPRF), while the latter mainly uses OPPRF and OKVS. 

The computation and communication complexities of the PSI in  \cite{DBLP:conf/ccs/KolesnikovMPRT17} are  $O(c\cdot m^{\st 2}+c\cdot m )$ and $O(c\cdot m^{\st 2})$ respectively, where $m$ is the number of clients. Later, to achieve efficiency, Chandran \et \cite{ChandranD0OSS21} proposed a multi-party PSI that remains secure only if the minority of the parties is corrupt by a semi-honest adversary; thus, it offers a weaker security guarantee than  the one in \cite{DBLP:conf/ccs/KolesnikovMPRT17} does. The PSI in \cite{NevoTY21} has a parameter $t$ that determines how many parties can collude with each other and must be set before the protocol's execution, where $t\in \{2, m\}$. The protocol divides the parties into three groups, clients: $A_{\st 1},..A_{\st m-t-1}$, leader: $A_{\st m-t}$, and servers: $A_{\st m-t+1},..A_{\st m}$. Each client needs to send a set of messages to every server and the leader which jointly compute the final result. Hence, this protocol's overall computation and communication complexities are $O(c\cdot \kappa(m+t^{\st 2}-t(m+1)))$ and $O(c\cdot m\cdot \kappa)$ respectively.


Dong \et proposed a ``fair'' two-party PSI \cite{DBLP:conf/dbsec/DongCCR13} that ensures either both parties receive the result or neither does, even if a malicious party aborts prematurely during the protocol's execution. It uses homomorphic encryption,  zero-knowledge proofs, and polynomial representation of sets. The protocol's computation and communication complexities are $O(c^{\st 2})$ and $O(c)$  respectively. Since then, various fair two-party PSIs have been proposed, e.g.,  in \cite{DebnathD14,DebnathD16-,DebnathD16}. To date, the fair PSI in \cite{DebnathD16} is the most efficient one. It uses ElGamal encryption, verifiable encryption, and zero-knowledge proofs, which often impose a significant overhead. Its computation and communication cost is $O(c)$. So far, there exists no fair \emph{multi-party} PSI in the literature. Our \withFai is the first one.%, which is also efficient.  


 \textit{Delegated} PSIs use  cloud computing  for computation and/or storage, while preserving the privacy of  the computation inputs and outputs from the cloud. They can be divided further into protocols that support \textit{one-off} and \textit{repeated} delegation of PSI computation. The former like \cite{kamarascaling,kerschbaum12,c18} cannot reuse their outsourced encrypted data and require clients to re-encode their data locally for each  computation. The most efficient such protocol is \cite{kamarascaling}, which has been designed for the two-party setting and its computation and communication complexity is $O(c)$.  Those protocols that support repeated PSI delegation let clients outsource the storage of their encrypted data to the cloud only once, and then execute an unlimited number of computations on the outsourced data. 
 %
To date, the protocol in \cite{eopsi} is the most efficient PSI that supports repeated delegation in the semi-honest model. It relies on the polynomial representation of sets, pseudorandom function, and hash table. Its communication and computation complexities are $O(h\cdot d^{\st 2})$ and $O(h\cdot d)$ respectively, where $h$ is the total number of bins in the hash table, $d$ is a bin's capacity (often $d=100$), and $h\cdot d$ is linear with $c$.  Recently, a multi-party PSI that supports repeated delegation and efficient \emph{updates} has been proposed in \cite{AbadiDMT22}. It lets a party efficiently update its outsourced set securely. It is also in the semi-honest model and uses a pseudorandom function, hash table, and Bloom filter. It imposes $O(h\cdot d^{\st 2}\cdot m)$ and $O(h\cdot d\cdot m)$  computation and communication costs respectively, during the PSI computation. It also imposes $O(d^{\st 2})$  computation and communication overheads, during the update phase.  








 
 
 