% !TEX root =main.tex

\section{Related Work}\label{sec::related-work}


Since their introduction in \cite{DBLP:conf/eurocrypt/FreedmanNP04}, various PSIs have been designed. PSIs can be divided into \textit{traditional} and \textit{delegated} ones.  


In \textit{traditional} PSIs, data owners interactively compute the result using their local data. 
%
Very recently, Raghuraman and Rindal \cite{RaghuramanR22} proposed two two-party PSIs, one secure against semi-honest/passive and the other against malicious/active adversaries. To date, these two protocols are the fastest two-party PSIs. They mainly rely on  Oblivious Key-Value Stores (OKVS) data structure and Vector Oblivious Linear Evaluation (VOLE). The protocols' computation cost is $O(c)$, where $c$ is  a set's cardinality.  They also impose $O(c\log c^{\st 2}+\kappa)$ and $O(c\cdot \kappa)$ communication costs in the semi-honest and malicious security models respectively, where $l$ is a set element's bit-size, and  $\kappa$ is a security parameter.  
%
Also, researchers designed PSIs that  allow multiple (i.e., more than two) parties to efficiently compute the intersection. The multi-party PSIs in  \cite{DBLP:conf/scn/InbarOP18,DBLP:conf/ccs/KolesnikovMPRT17} are secure against  passive adversaries while those in \cite{Ben-EfraimNOP21,GhoshN19,ZhangLLJL19,DBLP:conf/ccs/KolesnikovMPRT17,NevoTY21} were designed to remain secure against  active ones. However, Abadi \et  \cite{AbadiMZ21} showed that the PSIs in  \cite{GhoshN19} are susceptible to several attacks.  To date, the  protocols  in   \cite{DBLP:conf/ccs/KolesnikovMPRT17} and  \cite{NevoTY21} are the most  efficient multi-party PSIs  designed to be  secure against passive and active  adversaries respectively. These protocols are secure even if  the majority of parties are corrupt.  
%
%The PSIs in  \cite{DBLP:conf/ccs/KolesnikovMPRT17,NevoTY21} to keep the overall costs low and avoid requiring all clients to interact with each other in all steps of the protocols, use a ``leader'' client which interacts with the rest of the clients. 
%
The former relies on inexpensive symmetric key primitives such as  Programmable Pseudorandom Function (OPPRF) and Cuckoo Hashing, while the latter mainly uses OPPRF and OKVS. 

The overall computation and communication complexities of the PSI in  \cite{DBLP:conf/ccs/KolesnikovMPRT17} are  $O(c\cdot m^{\st 2}+c\cdot m )$ and $O(c\cdot m^{\st 2})$ respectively, as each client needs to interact with the rest (in the ``Conditional Zero-Sharing'' phase), where $m$ is the number of clients. Later, to achieve efficiency, Chandran \et \cite{ChandranD0OSS21} proposed a multi-party PSI that remains secure only if the minority of the parties is corrupt by a semi-honest adversary; thus, it offers a weaker security guarantee than  the one in \cite{DBLP:conf/ccs/KolesnikovMPRT17} does. The PSI in \cite{NevoTY21} has a parameter $t$ that determines how many parties can collude with each other and must be set before the protocol's execution, where $t\in \{2, m\}$. The protocol divides the parties into three groups, clients: $A_{\st 1},..A_{\st m-t-1}$, leader: $A_{\st m-t}$, and servers: $A_{\st m-t+1},..A_{\st m}$. Each client needs to send a set of messages to every server and the leader which jointly compute the final result. Hence, this protocol's overall computation and communication complexities are $O(c\cdot \kappa(m+t^{\st 2}-t(m+1)))$ and $O(c\cdot m\cdot \kappa)$ respectively.


Dong \et proposed a ``fair'' two-party PSIs \cite{DBLP:conf/dbsec/DongCCR13} that ensure either both parties receive the result or neither does, even if a malicious party aborts prematurely during the protocol's execution. The protocol relies on homomorphic encryption,  zero-knowledge proofs, and polynomial representation of sets. The protocol's  computation and communication complexities are $O(c^{\st 2})$ and $O(c)$  respectively. Since then, various fair two-party PSIs have been proposed, e.g.,  in \cite{DebnathD14,DebnathD16-,DebnathD16}. To date, the fair PSI in \cite{DebnathD16} is the most efficient one. It mainly relies on a combination of ElGamal encryption, verifiable encryption, and zero-knowledge proofs, which often impose a significant overhead. The protocol's computation and communication cost is $O(c)$. So far, there exists no fair \emph{multi-party} PSI in the literature. Our \withFai is the first  fair {multi-party} PSI.%, which is also efficient.  


 \textit{Delegated} PSIs use  cloud computing  for computation and/or storage, while preserving the privacy of  the computation inputs and outputs from the cloud. They can be divided further into protocols that support \textit{one-off} and \textit{repeated} delegation of PSI computation. The former like \cite{kamarascaling,kerschbaum12,c18} cannot reuse their outsourced encrypted data and require clients to re-encode their data locally for each  computation. The most efficient such protocol is \cite{kamarascaling}, which has been designed for the two-party setting and its computation and communication complexity is $O(c)$.  In contrast, those protocols that support repeated PSI delegation let clients outsource the storage of their encrypted data to the cloud only once, and then execute an unlimited number of computations on the outsourced data. 
 %
To date, the protocol in \cite{eopsi} is the most efficient PSI that supports repeated delegation in the semi-honest model. It relies on the polynomial representation of sets, pseudorandom function, and hash table. Its overall communication and computation complexities are $O(h\cdot d^{\st 2})$ and $O(h\cdot d)$ respectively, where $h$ is the total number of bins in the hash table, $d$ is a bin's capacity (often $d=100$), and $h\cdot d$ is linear with $c$.  Recently, a multi-party PSI that supports repeated delegation and efficient \emph{updates} has been proposed in \cite{AbadiDMT22}. It allows a party to efficiently update its outsourced set securely. It is also in the semi-honest model and uses a pseudorandom function, hash table, and Bloom filter. The protocol imposes $O(h\cdot d^{\st 2}\cdot m)$ and $O(h\cdot d\cdot m)$  computation and communication costs respectively, during the PSI computation. It also imposes $O(d^{\st 2})$  computation and communication overheads, during the update phase.  








 
 
 