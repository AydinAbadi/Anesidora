% !TEX root =main.tex


\vspace{-3mm}



\section{Other Subroutines Used in \withFai}\label{sec::subroutines}
\vspace{-.5mm}

In this section, we present three subroutines and a primitive that we developed and are used in the instantiation of \p, i.e., \withFai. 


\vspace{-2mm}
\subsection{Verifiable Oblivious Polynomial Randomisation (\vopr)}\label{sec::vopr}
\vspace{-.5mm}

%In this section, we present ``Verifiable Oblivious Polynomial Randomisation'' (VOPR) protocol. 

In the \vopr, two parties are involved, (i) a sender which is potentially a passive adversary and (ii) a receiver that is potentially an active adversary. The protocol allows the receiver with input polynomial $\bm\beta$ (of degree $e'$) and the sender with input random polynomials $\bm\psi$ (of degree $e$) and  $\bm{\alpha}$ (of degree $e+e'$)   to compute: $\bm\theta=\bm\psi\cdot \bm\beta+\bm\alpha$, such that (a) the receiver learns only $\bm\theta$ and nothing about the sender's input even if it sets $\bm \beta=0$, (b) the sender learns nothing, and (c) the receiver's misbehaviour is detected in the protocol. Thus, the functionality that  \vopr computes is defined as $f^{\st {\vopr}}( (\bm\psi, \bm{\alpha}), \bm\beta)\rightarrow(\bot, \bm\psi\cdot \bm\beta+\bm\alpha)$. 
%
We will use {\vopr} in \withFai for two main reasons:  (a) to let a party re-randomise its counterparty's polynomial (representing its set) and (b) to impose a MAC-like structure to the randomised polynomial; such a structure will allow a verifier to detect if \vopr's output has been modified. 

Now, we outline how we design \vopr without using any (expensive) zero-knowledge proofs.\footnote{Previously, Ghosh \textit{et al.}  \cite{GhoshN19} designed a protocol called Oblivious Polynomial Addition (OPA) to meet similar security requirements that we laid out above. But, as shown in \cite{AbadiMZ21}, OPA  is susceptible to several serious attacks. } In the setup phase, both parties represent their input polynomials in the regular coefficient form; therefore, the sender's polynomials are defined as $\bm\psi=\sum\limits^{\st e}_{\st i=0}g_{\st i}\cdot x^{\st i}$ and  $\bm\alpha=\sum\limits^{\st e+e'}_{\st j=0}a_{\st j}\cdot x^{\st j}$ and the receiver's polynomial is defined as $\bm\beta=\sum\limits^{\st e'}_{\st i=0}b_{\st i}\cdot x^{\st i}$, where $b_{\st i}\neq 0$. However, the sender computes each coefficient $a_{\st j}$ (of polynomial $\bm \alpha$) as follows,  $a_{\st j}=\sum\limits^{\substack{\st k=e'\\ \st t=e}}_{\st t,k=0} a_{\st t,k}$,  where  $t+k=j$ and each $a_{\st t,k}$ is a random value. For instance, if $e=4$ and $e'=3$, then $a_{\st 3}=a_{\st \st 0,3}+a_{\st 3,0}+a_{\st 1,2}+a_{\st 2,1}$. Shortly, we explain why polynomial $\bm\alpha$ is constructed this way. 



In the computation phase,  to compute polynomial $\bm\theta$, the two parties interactively multiply and add the related coefficients in a secure way using $\ole^{\st +}$ (presented in Section \ref{sec::OLE-plus}). Specifically,
%
%For simplicity, let $i=0$. 
%
for every $j$  (where $0\leq j\leq e'$) the sender sends $g_{\st i}$ and $a_{\st i,j}$ to an instance of  $\ole^{\st +}$, while the receiver sends $b_{\st j}$ to the same instance,  which returns $c_{\st i,j}=g_{\st i}\cdot b_{\st j}+ a_{\st i,j}$ to the receiver. This process is repeated for every $i$, where $0 \leq i \leq e$. Then, the receiver uses $c_{\st i,j}$ values to construct the resulting polynomial, $\bm\theta=\bm\psi\cdot \bm\beta+\bm\alpha$.  


The reason that the sender imposes the above structure to (the coefficients of)  $\bm\alpha$ in the setup, is to let the parties securely compute $\bm\theta$ via  $\ole^{\st +}$. Specifically, by imposing this structure (1) the sender  can blind each product $g_{\st i}\cdot b_{\st j}$  with  random value $a_{\st i,j}$ which is a component of $\bm\alpha$'s coefficient and (2) the receiver can construct a result polynomial of the form $\bm\theta=\bm\psi\cdot \bm\beta+\bm\alpha$. 


To check the result's correctness, the sender picks and sends a random value $z$ to the receiver which computes  $\bm\theta(z)$ and $\bm\beta(z)$ and sends these two values  to the sender. The sender computes  $\bm\psi(z)$ and $\bm\alpha(z)$ and then checks if equation  $\bm\theta({ z})=\bm\psi({ z})\cdot \bm\beta({ z})+\bm\alpha({ z})$ holds. It accepts the result if the check passes.   

Figure \ref{fig:VOPR} describes \vopr in detail. Note, \vopr requires the sender to insert non-zero coefficients, i.e., $b_{\st i}\neq 0$ for all $i,0 \leq i \leq e'$. If the   sender inserts a zero-coefficient, then it will learn only a random value (due to  $\ole^{\st +}$), accordingly it cannot pass \vopr's verification phase. However, such a requirement will not affect Justitia's correctness, as we will discuss in Section \ref{Fair-PSI-Protocol} and Appendix \ref{sec::error-prob}.  

\vspace{-3mm}

\input{VOPR}

\vspace{-1mm}
\begin{theorem}\label{theorem::VOPR}
%
Let $f^{\st \vopr}$ be the functionality defined above. If the enhanced \ole (i.e., $\ole^{\st +}$) is secure against malicious (or active) adversaries, then the  Verifiable Oblivious Polynomial Randomisation (\vopr), presented in Figure \ref{fig:VOPR}, securely computes $f^{\st \vopr}$ in the presence of (i) a semi-honest sender and honest receiver or (ii) a malicious receiver and honest sender. 
%
\end{theorem}

\vspace{-1mm}
We refer readers to Appendix \ref{sec::proof-of-vopr} for the proof of Theorem \ref{theorem::VOPR}. 


\input{ZSPA.tex}

%\input{Arbiter-algorithm}

\input{Arbiter-protocol.tex}