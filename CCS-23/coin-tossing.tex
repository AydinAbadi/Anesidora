% !TEX root =main.tex





\section{Coin-Tossing Protocol}\label{sec::coin-tossing}

A Coin-Tossing protocol, \ct, allows two mutually distrustful parties, say $A$ and $B$, to jointly generate a single random bit. Formally, \ct computes the functionality $\fct(in_{\st A}, in_{\st B})\rightarrow (out_{\st A}, out_{\st B})$, which takes $in_{\st A}$ and  $in_{\st B}$ as inputs of $A$ and $B$ respectively and outputs $out_{\st A}$ to $A$ and $out_{\st B}$ to $B$, where $out_{\st A}=out_{\st B}$. A basic security requirement of a \ct is that the resulting bit is (computationally) indistinguishable from a truly random bit. 

Blum proposed a simple \ct in \cite{Blum82} that works as follows. Party $A$ picks a random bit $in_{\st A}\stackrel{\st \$}\leftarrow\{0,1\}$, commits to it and sends the commitment to $B$ which sends its choice of random input, $in_{\st B}\stackrel{\st \$}\leftarrow\{0,1\}$, to $A$. Then, $A$ sends the opening of the commitment (including $in_{\st A}$) to $B$, which checks whether the commitment matches its opening. If so, each party computes the final random bit as $in_{\st A}\oplus in_{\st B}$.  

There have also been \emph{fair} coin-tossing protocols, e.g., in \cite{MoranNS09}, that ensure either both parties learn the result or nobody does. These protocols can be generalised to \emph{multi-party} coin-tossing protocols to generate a \emph{random string} (rather than a single bit), e.g., see \cite{BeimelOO10,KiayiasRDO17}.
%
The overall computation and communication complexities of (fair) multi-party coin-tossing protocols are often linear with the number of participants. In this paper, any secure multi-party \ct that generates a random string can be used. For the sake of simplicity, we let a multi-party \fct take $m$ inputs and output a single value, i.e., $\fct(in_{\st 1}, ..., in_{\st m})\rightarrow out$. 



