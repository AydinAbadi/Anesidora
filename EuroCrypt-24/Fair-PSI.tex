% !TEX root =main.tex

\vspace{-3.6mm}

\section{Definition of \p}\label{sec::F-PSI-model}%\label{Fair-PSI-Protocol}


\vspace{-1.4mm}


Now, we present the concept of multi-party PSI with Fair Compensation  (\p) which ensures that  either all clients receive the result or that honest parties are financially compensated in the event of an unfair protocol abortion, wherein only dishonest parties gain access to the result.  
%
In a  $\mathcal{PSI}^{\st \mathcal{FC}}$, three types of parties are involved; namely, (1) a set of clients $\{A_{\st 1},...,A_{\st m}\}$ potentially \emph{malicious} (i.e., active adversaries), where  all but one may collude with each other, (2) a non-colluding dealer, $D$, potentially semi-honest (i.e., a passive adversary), and (3) an auditor, \aud, potentially semi-honest, where all parties except \aud have input set. For simplicity, we assume that one can determine whether a given address belongs to \aud. The fundamental functionality computed by any  multi-party PSI can be defined as  $f^{\st\text{PSI}} (S_{\st 1},..., S_{\st m+1})\rightarrow\underbrace{(S_{\st\cap},..., S_{\st\cap})}_{\st m+1}$, where $S_{\st\cap}= S_{\st 1} \cap S_{\st 2}, ...,\cap\  S_{\st m+1}$.  

At a high level, the standard simulation-based paradigm ensures only privacy and output correctness \cite{DBLP:books/cu/Goldreich2004}. To enhance the standard simulation-based model and accommodate additional security requirements (such as fairness, compensation, or transactions' correctness) researchers often follow these steps: (i) define a set of predicates and (ii) define a wrapper that encapsulates and  parameterises the original paradigm with the defined predicates. This approach can be observed in \cite{KiayiasZZ16,BadertscherMTZ17,BadertscherGKRZ19}. Consequently, to formally define a \p, we parameterise $f^{\st\text{PSI}}$ with four predicates,  $Q:=(\qinit, \qdel, \qUnFAbt, \qFAbt)$, which ensure that certain financial conditions are met. We borrow three of these predicates (i.e., $\qinit, \qdel, \qUnFAbt$) from \cite{KiayiasZZ16}. Nevertheless, we will (i) introduce an additional predicate  \qFAbt and (ii) provide more formal accurate definitions of these predicates. Below, we provide a brief description of these predicates.% (in Appendix \ref{sec::Formal-Definitions-of-F-PSI-Predicates}). 






   %  that are invoked after the functionality $f^{\st \text{PSI}}$ is executed. 
%   We borrow  $\qinit, \qdel$ and $\qUnFAbt$ from \cite{KiayiasZZ16}; nevertheless, we will (i) introduce an additional predicate  \qFAbt and (ii) provide more formal accurate definitions of these predicates. 

\vspace{-1.7mm}
\begin{itemize}
    \item[$\bullet$]  \qinit  defines the conditions under which a protocol realising \p should begin execution, i.e., when all set owners have sufficient deposit. 
 
  \item[$\bullet$] \qdel determines the circumstances in which parties receive their output, specifically when honest parties receive their deposit back.
 
  \item[$\bullet$] \qUnFAbt specifies the conditions under which the simulator can force parties to abort if the adversary learns the output, i.e., when an honest party receives its deposit back along with a predefined amount of compensation.
 
 
 
 \item[$\bullet$] \qFAbt specifies the conditions under which the simulator can compel parties to abort if the adversary receives no output, i.e., when honest parties receive their deposits back. 
 
   \end{itemize}
   \vspace{-2.8mm}
%
%We observed that the latter predicate should have been defined in the generic framework in \cite{KiayiasZZ16} too; as the framework should have also captured the cases where an adversary may abort without learning any output after the onset of the protocol.  

By requiring any protocol that realises \p to implement a wrapped version of $f^{\st\text{PSI}}$ that includes $Q$, we will ensure that an honest set owner only aborts in an unfair manner if \qUnFAbt returns  $1$, it only aborts in a fair manner if \qFAbt returns  $1$, and outputs a valid value if \qdel returns $1$. We refer readers to Appendix \ref{sec::Formal-Definitions-of-F-PSI-Predicates} for formal definitions of these predicates.   Next, we present a formal definition of \p. 
 

% 
% 
% \begin{definition}
% %
%  [\qinit: Initiation predicate] Let $\mathcal{G}$ be a stable ledger, $adr_{\st sc}$ be smart contract $sc$'s address, $Adr$ be a set of $m+1$ distinct addresses, and $\xc$ be a fixed amount of coins. Then, predicate $\qinit(\mathcal{G}, adr_{\st sc}, m+1, Adr, \xc)$ returns $1$ if every address in $Adr$ has at least $\xc$ coins in $sc$; otherwise, it returns $0$. 
% %
% \end{definition}
%
% 
% 
%    \begin{definition}  [\qdel:
%    %
%    Delivery predicate] Let $pram:=(\mathcal{G}, adr_{\st sc}, \xc)$ be the parameters defined above, and   $adr_{\st i}\in Adr$ be the address of an honest party. 
%    %
%%    Let also $G$ be a compensation function that takes as input  two parameters $(deps, m')$, where $deps$ is the amount of coins  that all $m+1$ parties  deposit; it returns the amount of compensation each honest party must receive, i.e., $G(deps, m')\rightarrow c'$. 
%    %
%    Then, predicate $\qdel(pram, adr_{\st i})$ returns $1$ if $adr_{\st i}$ has sent $\xc$ amount to $sc$ and received  $\xc$ amount from it; thus,  its balance in $sc$ is $0$. Otherwise, it returns $0$. 
% %
%  \end{definition}
% 
% 
% 
%   \begin{definition}  [\qUnFAbt: UnFair-Abort predicate]
%   %
% Let $pram:=(\mathcal{G}, adr_{\st sc}, \xc)$ be the parameters defined above, and $Adr'\subset Adr$ be a set containing honest parties' addresses, $m' = |Adr'|$,  and   $adr_{\st i}\in Adr'$. Let also $G$ be a compensation function that takes as input  three parameters $(\depsc, adr_{\st i}, m')$, where $\depsc$ is the amount of coins  that all $m+1$ parties  deposit. It returns the amount of compensation each honest party must receive, i.e., $G(\depsc, ard_{\st i}, m')\rightarrow \xci$. Then, predicate $\qUnFAbt$ is defined as $\qUnFAbt(pram, G, \depsc, m', adr_{\st i})\rightarrow (a,b)$, where $a=1$ if $adr_{\st i}$ is an honest party's address and $adr_{\st i}$ has sent $\xc$ amount to $sc$ and received  $\xc+\xci$  from it, and $b=1$ if $adr_{\st i}$ is \aud's address and $adr_{\st i}$ received $\xci$  from $sc$. Otherwise, $a=b=0$. 
%  %
%  \end{definition}
%  
%  
%\begin{definition}  [\qFAbt: Fair-Abort predicate]
%   %
% Let $pram:=(\mathcal{G}, adr_{\st sc}, \xc)$ be the parameters defined above, and $Adr'\subset Adr$ be a set containing honest parties' addresses, $m' = |Adr'|$,     $adr_{\st i}\in Adr'$, and  $adr_{\st j}$ be \aud's address. Let $G$ be the compensation function, defined above and let $G(deps, ard_{\st j}, m')\rightarrow \xc_{\st j}$ be the compensation that the auditor must receive.  Then, predicate $\qFAbt(pram, G, \depsc, m', adr_{\st i}, adr_{\st j})$ returns $1$, if $adr_{\st i}$ (s.t. $adr_{\st i}\neq adr_{\st j}$) has sent $\xc$ amount to $sc$ and received  $\xc$  from it, and $adr_{\st j}$ received $\xc_{\st j}$  from $sc$. Otherwise, it returns $0$. 
%  %
% \end{definition}
  
  
  
 
%Note that we have upgraded the simulation-based definition of secure computation (i.e., Definition \ref{def::MPC-active-adv}) to define the security requirements of \p, by incorporating the above predicates into the definition. 
 
 \vspace{-1mm}
 
\begin{definition}[\p]\label{def::PSI-Q-fair}
Let $f^{\st \text{PSI}}$ be the multi-party PSI functionality defined above. Then, protocol $\Gamma$ realises  $f^{\st \text{PSI}}$ with $Q$-fairness in the presence of $m-1$ static active-adversary clients (i.e., $A_{\st j}$s) or a static passive dealer $D$ or passive auditor $Aud$, if for every PPT adversary $\mathcal{A}$ for the real model, there exists a PPT adversary (or simulator) $\mathsf{Sim}$ for the ideal model, such that for every $I\in \{A_{\st 1},...,A_{\st m}, D, Aud\}$, it holds that: 
%\begin{equation*}
$\{\mathsf {Ideal}^{\st \mathcal{W}(f^{\st \text{PSI}},Q)}_{\st \mathsf{Sim}(z), I}(S_{\st 1},..., S_{\st m+1})\}_{\st S_{\st 1},..., S_{\st m+1},z}\\\stackrel{c}{\equiv} \{\mathsf{Real}_{\st \mathcal{A}(z), I}^{\st \Gamma}(S_{\st 1},..., S_{\st m+1}) \}_{\st S_{\st 1},..., S_{\st m+1}, z}$,  
%\end{equation*}
where  $z$ is an auxiliary input given to $\mathcal{A}$ and  $\mathcal{W}(f^{\st \text{PSI}},Q)$ is a functionality that wraps $f^{\st \text{PSI}}$ with predicates $Q:=(\qinit, \qdel,$ $\qUnFAbt, \qFAbt)$. 
  \end{definition}
 
%   \begin{definition}  [$Q^{\st \text{Del}}$:
%   %
%    Delivery predicate] Let $pram:=(\mathcal{G}, adr_{\st sc}, c)$ be the parameters defined above, and   $adr_{\st i}\in Adr$ be the address of an honest party. Let also $G$ be a compensation function that takes as input  two parameters $(deps, m')$, where $deps$ is the amount of coins  that all $m+1$ parties  deposit; it returns the amount of compensation each honest party must receive, i.e., $G(deps, m')\rightarrow c'$. Then, predicate $Q^{\st \text{Del}}(pram, G, deps, m', adr_{\st i})$ returns $1$ if $adr_{\st i}$ has sent $c$ amount to $sc$ and received  $c+c'$  from it. Otherwise, it returns $0$. 
% %
%  \end{definition}
 
 
 
%  \begin{definition}  [$Q^{\st \text{Abt}}$: Abort predicate]
% Let $pram:=(\mathcal{G}, adr_{\st sc}, c)$ be the parameters defined above, and $Adr'\subset Adr$ be a set containing honest parties' addresses, $m' = |Adr'|$,  and   $adr_{\st i}\in Adr'$. Let also $G$ be a compensation function that takes as input  three parameters $(deps, adr_{\st i}, m')$, where $deps$ is the amount of coins  that all $m+1$ parties  deposit, $adr_{\st i}$ is an hones party's address, and $m' = |Adr'|$; it returns the amount of compensation each honest party must receive, i.e., $G(deps, ard_{\st i}, m')\rightarrow c_{\st i}$. Then, predicate $Q^{\st \text{Abt}}(pram, G, deps, m', adr_{\st i})$ returns $1$ if $adr_{\st i}$ has sent $c$ amount to $sc$ and received  $c+c'$  from it. Otherwise, it returns $0$. 
%  
%  \end{definition}
 
 %Recall, the standard simulation-based model (presented in Section \ref{}) can adequately capture the security definition of secure multi-party computation and accordingly regular PSI; however, it is not 
 

 
\vspace{-3mm}
  
\input{Sub-protocols.tex}
  
\input{Unforgeable-polynomials}


 \vspace{-2.3mm}
\section{Concrete Construction of \p}

\vspace{-.3mm}
 
% %%%%%%%%%%%%%
%\subsection{Main Challenges to Overcome}
%
% We need to address several key challenges, to design an efficient scheme that realises \p. Below, we outline these challenges.
% 
%  \vspace{-1mm}
% \subsubsection{Keeping Overall Complexities Low.}
% 
% In general, in multi-party PSIs, each client needs to send messages to the rest of the clients and/or engage in secure computation with them, e.g., in \cite{DBLP:conf/scn/InbarOP18,DBLP:conf/ccs/KolesnikovMPRT17}, which would result in communication and/or computation quadratic with the number of clients. To address this challenge, we  (a) allow one of the clients as a dealer to interact with the rest of the clients,\footnote{This approach has similarity with the non-secure PSIs in \cite{GhoshN19}.} and   (b) we use a smart contract, which acts as a bulletin board to which most messages are sent and also performs lightweight computation on the clients' messages. The combination of these approaches will keep the overall communication and computation linear with the number of clients (and sets' cardinality). 
% 
% 
% \vspace{-2mm}
% 
% \subsubsection{Randomising Input Polynomials.}  In multi-party PSIs that use the polynomial representation, it is essential that a client's input polynomial be randomised by another client \cite{AbadiMZ21}. To do that securely and efficiently, we require the dealer and each client together to engage in an instance of \vopr, which we developed in Section \ref{sec::subroutines}. 
% 
%  \vspace{-2mm}
% 
% \subsubsection{Preserving the Privacy of Outgoing Messages.} Although the use of public smart contracts (e.g., Ethereum) will help keep overall complexity low, it introduces another challenge; namely, if clients do not protect the privacy of the messages they send to the smart contracts, then other clients (e.g., dealer) and non-participants of PSI (i.e., the public) can learn the clients' set elements and/or the intersection. To efficiently protect the privacy of each client's messages (sent to the contracts) from the dealer, we require the clients (except the dealer) to engage in \zspaa which lets each of them generate a pseudorandom polynomial with which it can blind its message. To protect the privacy of the intersection from the public, we require all clients to run a coin-tossing protocol to agree on a blinding polynomial, with which the final result that encodes the intersection on the smart contract will be blinded.  
% 
% 
%  \vspace{-2mm}
% \subsubsection{Ensuring the Correctness of Subroutine Protocols' Outputs.} 
% 
% In general, any MPC that must remain secure against an active adversary is equipped with a verification mechanism that ensures an adversary is detected if it affects messages' integrity, during the protocol's execution. This is the case for the subroutine protocols that we use, i.e., \vopr and \zspaa. However, this type of check itself is not always sufficient. Because in certain cases, the output of an MPC may be fed as input to another MPC and we need to ensure that the \emph{intact} output of the first MPC is fed to the second one. This is the case in our PSI's subroutines too. To address this challenge, we use unforgeable polynomials; specifically, the output of \vopr is an unforgeable polynomial (that encodes the actual output). If the adversary tampers with the \vopr's output and uses it later, then a verifier can detect it. We will have the same integrity guarantee for the output of \zspaa for free. Because (i) \vopr is called before \zspaa, and (ii) if clients use intact outputs of \zspaa, then the final result (i.e., the sum of all clients' messages) will not contain any output of \zspaa, as they will cancel out each other. Thus, by checking the correctness of the final result, one can ensure the correctness of the outputs of \vopr and \zspaa, in one go. 
% %%%%%%%%%%%%%%
 
 

\vspace{-2mm}
  
\subsection{An Overview of \withFai (\fpsi)}\label{Fair-PSI-Protocol}
%This section presents \fpsi, a protocol that realises \p. 

%\subsubsection{An Overview.} 

\vspace{-1mm}

At a very high level, \withFai (\fpsi) operates as follows. Initially, each client encodes its set elements into a polynomial. Subsequently, all clients collectively sign a smart contract \scf and make a predefined coin deposit into it. One of the clients, designated as the dealer, $D$, takes on the responsibility of randomising the polynomials of the remaining clients and applying a specific structure to their respective polynomials. The clients also randomise $D$'s polynomials. Following this, all clients transmit their randomised polynomials to \scf.  

 \scf consolidates all the polynomials and verifies whether the resultant polynomial still adheres to the structure imposed by $D$. If it determines that the resultant polynomial lacks the prescribed structure, it then triggers an auditor, \aud, to identify clients who may have acted improperly and impose penalties on them. However, if the resultant polynomial indeed maintains the required structure,  \scf produces an encoded polynomial and reimburses the deposits made by the clients. In this scenario, all clients can utilise the resulting polynomial (as provided by \scf) to determine the intersection. Figure \ref{fig:parties-interactions-in-Jus} in Appendix \ref{sec::Justitia-workflow} outlines the interaction among the parties. 





%%%%%%%%%%%%


One of the novelties of \fpsi is its lightweight verification mechanism, which enables a smart contract  \scf to efficiently  validate the accuracy of clients' messages while preserving the confidentiality of the clients' set elements. To achieve this, $D$ randomises each client's polynomials and constructs unforgeable polynomials on the randomised polynomials.  If any client alters an unforgeable polynomial it receives and subsequently sends the modified polynomial to \scf,  then  \scf can detect this manipulation by verifying if the sum of all clients' (unforgeable) polynomials is divisible by a specific polynomial of degree $1$.  This verification process is considered lightweight for several reasons: (i) it does not use any public key cryptography, which can often be computationally expensive, (ii) it only requires polynomial division, and (iii) it can perform batch verification by aggregating all clients' randomised polynomials and then verifying the correctness of the result. 


%%%%%%%%%%%%




%
%One of the novelties of F-PS is a lightweight verification mechanism which allows a smart contract to efficiently verify the correctness of the clients' messages without being able to learn/reveal the clients' set elements. To achieve this, the dealer during randomising other clients' polynomials, imposes a MAC-like structure on the randomised polynomials, such that if a client (who receives its randomised polynomial) tampers with it, then the smart contract would detect it. To do the verification, the smart contract needs to only check whether the sum of all clients' randomised polynomials is divisible by a polynomial of degree $1$.  The verification is lightweight because: (i) it does not rely on any public key cryptography (i.e., zero-knowledge proofs), (ii) it needs to perform only polynomial division, and (iii) it can perform batch verification, i.e., instead of individually checking each client's randomised polynomial, it sums all clients randomised polynomials (related to a hash table's bin) and then checks the result's correctness.


% his own
%outsourced dataset and having any knowledge of the other client’s dataset 
%
%
% mainly stems from our observation (stated  in Theorem \ref{proof::unforgeable-poly}) which leads to an  efficient verification mechanism carried out by the contract. 


Now, we will delve into a more detailed description of \fpsi. Initially, all clients sign and deploy \scf, each contributing a predetermined deposit amount to it. Subsequently, they collectively execute a coin-tossing protocol \ct to reach a consensus on a key, $mk$. This key will be used to generate a series of blinding polynomials, concealing the final result from the public. 
%
Following this, each client independently maps its set elements to a hash table and represents the contents of each bin in the hash table as a polynomial, $\bm\pi$. Afterward, for each bin, the following steps are undertaken.  All clients, excluding $D$, participate in \zspaa to reach an agreement on a set of pseudorandom blinding factors, ensuring that their sum equals zero. 
%
Next, $D$ takes on the task of randomising each client's polynomial $\bm\pi$ and constructing an unforgeable polynomial on it. To achieve this, $D$ and every other client, $C$, participate in \vopr. This process results in
$C$ receiving a polynomial. Following this, $D$ and each $C$ invoke \vopr once more, this time to randomise $D$'s polynomial, resulting in $C$ obtaining another unforgeable polynomial. 
%
Note that the output of \vopr does not reveal any information about any client's original polynomial $\bm\pi$. This is because $D$  has previously concealed this polynomial with another secret random polynomial during the execution of
  \vopr. 
  
  Each $C$ adds the two polynomials together, applies blinding (using the output of  \zspaa), and then forwards the result to \scf. 
%
 Once all clients have transmitted their input polynomials to \scf, $D$ sends a \textbf{switching polynomial}  to \scf.  This switching polynomial allows \scf to obliviously alter the secret blinding polynomials previously employed by $D$ during the execution of \vopr. This alteration ensures that each client's original polynomial $\bm \pi$ is blinded with a different blinding polynomial, which can be independently generated and removed by all clients themselves using the key $mk$.  %The switching polynomial is constructed in a way that does not affect the verification of unforgeable polynomials. 

Following this, $D$ transmits a secret polynomial $\bm\zeta$ to \scf. This polynomial enables \scf to validate the correctness of unforgeable polynomials. Subsequently, \scf\ sum all clients' polynomials together and checks if $\bm\zeta$ can divide the sum. \scf approves the clients' inputs if the polynomial can divide the sum; otherwise, it invokes \aud to identify misbehaving parties.  


In the event of such misbehaviour, all honest parties receive a refund of their deposits, while the deposits of the misbehaving parties are redistributed among the honest ones. If all clients behave honestly,  then each client can independently ascertain the intersection. To achieve this, they use $mk$ to remove the blinding polynomial from the sum (that the contract generated), evaluate the unblinded polynomial at each of their set elements, and consider an element to be part of the intersection if the evaluation yields zero. 
%The efficiency of the verification in our protocol  mainly stems from our  observation that if an adversary who know only $xx$ modified the polynomial of the form $xx$ then $\zeta$ will not divide result polynomial after unblinding will not divide with a high probability.  

\vspace{-3.5mm}
\subsection{Detailed Description of \fpsi.}
\vspace{-1mm}

 Now, we will provide an in-depth explanation of how \fpsi  operates. (For a description of the main notations used, please refer to Table \ref{table:notation-table} in Appendix \ref{sec::notation-table}). 

\vspace{-2.5mm}
\begin{enumerate}[leftmargin=.55cm]

%\item[$\bullet$] \textbf{Input:} a pseudorandom function: $\mathtt{PRF}$, a hash table's parameters (i.e., the  total number of bins: $h$ and a bin's capacity: $d$), and clients' sets: $S^{\st (I)}$, where $I\in \bar{P}$.

%\item[$\bullet$] \textbf{Output:}  for every bin of the hash table, it outputs a polynomial: $\phi$, whose roots are  encrypted sets elements (of the bin) in the intersection.
\item\label{gen-FPSI-cont} All clients in $\cl=\{ A_{\st 1},...,   A_{\st m},  D\}$ sign a smart contract: \scf and deploy it to a blockchain. Each client obtains the address of the deployed contract. Also, all clients participate in \ct to agree on a secret master key, $mk$.

\item \label{encode-encrypt} Each client in $\cl$  builds a  hash table,  $\mathtt{HT}$, and inserts the set elements into  it, i.e.,  $\forall i: \mathtt{H}( s_{\st i})={indx}$, then $ s_{\st i}\rightarrow \mathtt{HT}_{\st indx}$. It pads every bin with random dummy elements to $d$ elements (if needed). Then,  for every bin, it constructs a polynomial whose roots are the bin's content: $\bm\pi=\prod\limits^{\st d}_{\st i=1} (x-s'_{\st i})$, where $s'_{\st i}$ is either $s_{\st i}$ or a random value. 
%
\item \label{ZSPA} Every client $ C$ in $\cl\setminus D$, for every bin, agree on $b=3d+3$ vectors of pseudorandom blinding factors: $z_{\st i,j}$, such that the sum of each vector elements is zero, i.e., $\sum\limits^{\st m}_{\st j=1}z_{\st i,j}=0$, where $0\leq i\leq b-1$. To do that, they participate in step \ref{ZSPA::ZSPA-invocation} of \zspaa. By the end of this step, for each bin, they agree on a secret key $k$ (that will be used to generate the zero-sum values) as well as two values stored in $\mathcal{SC}_{\fpsi}$, i.e., $q$: the key's hash value and $g$: a Merkle tree's root. After time $t_{\st 1}$,  $D$ ensures that all other clients have agreed on the vectors (i.e., all provided ``approved''  to the contract). If the check fails, it halts. 
%
\item\label{F-PSI::each-client-deposit} Each client in $\cl$ deposits $\yc+\chc$ amount to $\mathcal{SC}_{\fpsi}$. After time $t_{\st 2}$, $\mathcal{SC}_{\fpsi}$ checks if in total $(\yc+\chc)\cdot (m+1)$ amount has been deposited. If the check fails, it refunds the clients' deposit is refunded and halts. 







\item\label{JUS::check-non-zero-coeff}  $D$ picks a  random polynomial $\bm\zeta \stackrel{\st\$}\leftarrow \mathbb{F}_{\st p}[X]$ of degree $1$, for each bin.  
It, for each client $C$, allocates to each bin two random polynomials: $\bm\omega^{\st(D,C)}, \bm\rho^{\st (D,C)}\stackrel{\st\$}\leftarrow \mathbb{F}_{\st p}[X]$ of degree $d$, and  two  random polynomials: $\bm\gamma^{\st (D,C)}, \bm\delta^{\st (D,C)} \leftarrow \mathbb{F}_{\st p}[X]$ of degree $3d+1$. Also, each client $C$, for each bin, picks two  random polynomials: $\bm\omega^{\st (C,D)}, \bm\rho^{\st (C,D)}\stackrel{\st\$}\leftarrow \mathbb{F}_{\st p}[X]$ of degree $d$, and checks polynomials $\bm\omega^{\st (C,D)}\cdot \bm\pi^{\st  {  {(C)}}}$ and  $\bm\rho^{\st (C,D)}$ do not contain zero coefficients. %It also evaluates each polynomial at every element of $\vv{\bm{x}}$ that results in  $\omega^{  {  {D,C}}}_{\st i}$ and $\rho^{  {  {D,C}}}_{\st i}$.




\item\label{e-psi::D-randomises}  $D$ randomises other clients' polynomials. To do so, for every bin, it invokes an instance of {\vopr} (presented in Fig. \ref{fig:VOPR}) with  each client $  C$; where  $D$ sends $\bm\zeta \cdot \bm\omega^{\st  {  {(D,C)}}}$ and $\bm\gamma^{\st  {  {(D,C)}}}$, while client $ C$ sends $\bm\omega^{\st  {  {(C,D)}}}\cdot \bm\pi^{\st  {  {(C)}}}$ to {\vopr}. Each client $C$, for every bin, receives a blind polynomial of the following form: 

 \vspace{-3mm}
$$\bm\theta^{  {  {(C)}}}_{\st 1}=\bm\zeta \cdot \bm\omega^{\st  {  {(D,C)}}}\cdot \bm\omega^{\st  {  {(C,D)}}}\cdot \bm\pi^{\st  {  {(C)}}}+\bm\gamma^{\st  {  {(D,C)}}}$$

 \vspace{-1mm}

 from {\vopr}. If any party aborts, the deposit would be refunded to all parties.

\item\label{e-psi::C-randomises} Each client $    {  C}$ randomises  $ {D}$'s polynomial. To do that, each client $    {  C}$, for each bin,  invokes an instance of {\vopr} with   $ {D}$,    where each client $    {  C}$  sends $\bm\rho^{\st  {  {(C,D)}}}$, while  ${D}$  sends $\bm\zeta\cdot\bm \rho^{\st  {  {(D,C)}}}\cdot \bm\pi^{  {  {(D)}}}$ and $\bm\delta^{\st  {  {(D,C)}}}$ to {\vopr}. Every client   $    {  C}$, for each bin,  receives a blind polynomial of the following form: 
%

 \vspace{-2.5mm}

$$\bm\theta^{  {  {(C)}}}_{\st 2}=\bm\zeta \cdot \bm\rho^{\st  {  {(D,C)}}}\cdot \bm\rho^{\st  {  {(C,D)}}}\cdot \bm\pi^{\st  {  {(D)}}}+\bm\delta^{\st  {  {(D,C)}}}$$

 \vspace{-1mm}
 
 from {\vopr}. If a party aborts, all parties get their deposit back. 


\item\label{blindPoly-C-sends-to-contract} Each client $ C$, for every bin, masks the sum of polynomials $\bm\theta^{\st  {  {(C)}}}_{\st 1}$ and $\bm\theta^{\st  {  {(C)}}}_{\st 2}$  using the blinding factors: $z_{\st i,c}$, generated in step \ref{ZSPA}. Specifically, it computes the following blind polynomial (for every bin):  
%
$\bm\nu^{ \st {  {(C)}} }= \bm\theta^{ \st {  {(C)}}}_{\st 1}+\bm\theta^{\st  {  {(C)}}}_{\st 2}+\bm \tau^{\st  {  {(C)}} }$, 
%
where $\bm\tau^{\st  {  {(C)}}}=\sum\limits^{\st 3d+2}_{\st i=0}z_{\st i,c}\cdot x^{\st i}$. Next, it sends  all $\bm\nu^{\st  {  {(C)}} }$ to $\mathcal{SC}_{\fpsi}$. If any party aborts, the deposit would be refunded to all parties.


%\item Client $    {  D}$ ensures all clients have sent their inputs to $\mathcal{SC}_{  {   {F-PSI}}}$. In the case where $m'$ parties do not provide their inputs, client $    {  D}$ aborts. In this case, the rest (including the dealer) get their deposit back. Also,  the deposit of the parties who did not send  inputs would be evenly distributed among the rest. The total amount each party above receives is: $y+\frac{m'\cdot y}{m-m'}$




%%
%\item Client $    {  D}$ and each client $    {  C}$ collaboratively, for each bin, generate a polynomial that will be used to (obliviously) check if  $    {  C}$ misbehaved during the computation of each $\bm\nu^{  {  {(C)}} }$. To do so, for every bin, client $    {  D}$ invokes an instance of $\mathtt{VOPR}$ with  each client $    {  C}$, where  client $    {  D}$ sends: $\bm\zeta$, while client $    {  C}$ sends $\bm\xi^{  {  {(C)}}}$ and $-\bm\tau^{  {  {(C)}}}$   to $\mathtt{VOPR}$, where $\bm\xi^{  {  {(C)}}}$ is a random polynomial of degree $3d+1$. Client $    {  D}$ for each  $    {  C}$'s bin recives the following polynomial: 
%%
%$$\bm\mu^{  {  {(D,C)}}} = \bm\zeta\cdot \bm\xi^{  {  {(C)}}}-\bm\tau^{  {  {(C)}}}$$
%%




\item\label{f-psi::D-gen-random-poly} ${D}$ ensures all clients sent their inputs to $\mathcal{SC}_{\fpsi}$. If the check fails, it halts and the deposit is  refunded to all parties. It allocates a pseudorandom polynomial $\bm\gamma'$ of degree $3d$, to each bin. To do so, it uses $mk$ to derive a key for each bin: $k_{\st  { {indx}}}=\mathtt{PRF}(mk, {    {   {indx}}})$ and  uses $k_{\st  { {indx}}}$ to generate $3d+1$ pseudorandom coefficients $g_{\st  { {j,indx}}}=\mathtt{PRF}(k_{\st  { {indx}}}, j)$ where $ 0\leq j \leq 3d$. Also, for each bin, it allocates a  random polynomial  $\bm\omega'^{\st  {  {(D)}}}$ of degree $d$. 

\item\label{f-psi::D-gen-switching-poly}  $ {D}$,  for every bin, computes a polynomial of the form:  
%
 \vspace{-4.1mm}

$$\bm\nu^{\st  {  {(D)}}}=\bm\zeta \cdot  \bm\omega'^{\st  {  {(D)}}}\cdot \bm\pi^{\st  {  {(D)}} }-\sum\limits^{\st  {   A}_{\st  {   m}}}_{\st   {  {C }= }   {   A}_{\st  {  1}}}(\bm\gamma^{\st  {  {(D,C)}}} + \bm\delta^{\st  {  {(D,C)}}}) + \bm\zeta \cdot \bm\gamma'$$ 

 \vspace{-2.2mm}
 
It sends to $\mathcal{SC}_{\fpsi}$  polynomials $\bm\nu^{\st  {  {(D)}}}$ and $\bm\zeta$, for each bin.

 \item\label{compute-res-poly}  $\mathcal{SC}_{\fpsi}$ takes the following steps:
 \begin{enumerate}[leftmargin=.7mm]
 \item for every bin, sums all related polynomials  provided by all clients in $\bar{P}$ as follows:
 %
 $\bm\phi= \bm\nu^{\st  {  {(D)}} }+\sum\limits^{\st  {   A}_{\st  {   m}}}_{\st   {  {C }= }   {   A}_{\st  {  1}}}\bm\nu^{\st  {  {(C)}} }
 = \bm\zeta\cdot \bigg(\bm\omega'^{\st  {  {(D)}}}\cdot \bm\pi^{\st  {  {(D)}} } +\sum\limits^{\st  {   A}_{  {   m}}}_{\st  {  {C }= }   {   A}_{\st  {  1}}}(\bm\omega^{\st  {  {(D,C)}}} \cdot \bm\omega^{\st  {  {(C,D)}}}\cdot \bm\pi^{\st  {  (C)}}) +\bm\pi^{\st  {  {(D)}}}\cdot\sum\limits^{\st  {   A}_{ \st {   m}}}_{\st  {C= }   {   A}_{\st  {  1}}}(\bm\rho^{\st  {  {(D,C)}}} \cdot \bm\rho^{\st  {  {(C,D)}}}) + \bm\gamma'\bigg)$

 
 
% \begin{equation*}
%\begin{split}
% \bm\phi&= \bm\nu^{\st  {  {(D)}} }+\sum\limits^{\st  {   A}_{\st  {   m}}}_{\st   {  {C }= }   {   A}_{\st  {  1}}}\bm\nu^{\st  {  {(C)}} }\\
% &= \bm\zeta\cdot \bigg(\bm\omega'^{\st  {  {(D)}}}\cdot \bm\pi^{\st  {  {(D)}} } +\sum\limits^{\st  {   A}_{  {   m}}}_{\st  {  {C }= }   {   A}_{\st  {  1}}}(\bm\omega^{\st  {  {(D,C)}}} \cdot \bm\omega^{\st  {  {(C,D)}}}\cdot \bm\pi^{\st  {  (C)}}) +\bm\pi^{\st  {  {(D)}}}\cdot\sum\limits^{\st  {   A}_{ \st {   m}}}_{\st  {C= }   {   A}_{\st  {  1}}}(\bm\rho^{\st  {  {(D,C)}}} \cdot \bm\rho^{\st  {  {(C,D)}}}) + \bm\gamma'\bigg)
%  \end{split}
%\end{equation*}
% \item\label{F-PSI:detect-misbehaving-party} ensures that, for every bin, $\bm\zeta$ divides $\bm\phi$. Otherwise, it aborts and Arbiter protocol (presented in Fig. \ref{fig:arbiter}) is invoked to find misbehaving parties.
 
  \item\label{F-PSI:detect-misbehaving-party} checks whether, for every bin, $\bm\zeta$ divides $\bm\phi$. If the check passes, it sets $Flag=True$. Otherwise, it sets $Flag=False$. 
  
   %aborts and Arbiter protocol (presented in Fig. \ref{fig:arbiter}) is invoked to find misbehaving parties.
 
 
% \item if the check passes (i.e., $Flag=True$), each party gets back its deposit (i.e., $y$ amount).
 \end{enumerate}
 
\item\label{F-PSI::flag-is-true} If $Flag=True$, then the following steps are taken:

\begin{enumerate}[leftmargin=.7mm]
 \item $\mathcal{SC}_{\fpsi}$ sends back each party's deposit, i.e., $\yc+\chc$ amount.
 
  \item each client (given $\bm\zeta$ and $mk$) finds the elements in the intersection as follows. 
  \begin{enumerate}
  \item derives a bin's pseudorandom polynomial, $\bm\gamma'$, from $mk$. 
  
  \item removes the blinding polynomial from each bin's polynomial: 
  %
  $\bm\phi'=\bm\phi-\bm\zeta\cdot \bm\gamma'$
  
  \item\label{F-PSI::find-intersection} evaluates each bin's unblinded polynomial at every element $s_{\st i}$ belonging to that bin and considers the element in the intersection if the evaluation is zero: i.e., $\bm\phi'(s_{\st i})=0$.
 
 \end{enumerate}
 
 
 \end{enumerate}
 
 \item\label{F-PSI::flag-is-false} If $Flag=False$, then the following steps are taken.
 
 

 
 \begin{enumerate}[leftmargin=.7mm]
 

 \item\label{auditor}  \aud asks every client $    {  C}$ to send to it the  $\mathtt{PRF}$'s key (generated in step \ref{ZSPA}), for every bin. It inserts the keys to $\vv k$.  It generates a list $\bar L$ initially empty. Then, for every bin,  \aud takes step \ref{ZSPA-A::Auditor-computation} of \zspaa, i.e., invokes  $\mathtt{Audit}(m, \vv{{k}},  q, \bm\zeta, 3d+3, g)\rightarrow (L, \vv{{\mu}})$.  Every time it invokes $\mathtt{Audit}$, it appends the elements of returned $L$ to $\bar L$.  \aud for each bin sends  $ \vv{{\mu}}$ to $\mathcal{SC}_{\fpsi}$. It also sends  to $\mathcal{SC}_{\fpsi}$ the list $\bar L$ of all misbehaving clients detected so far.
 

 
 \item to  help identify further  misbehaving clients, $D$ takes the following steps,  for each bin of client $    {  C}$ whose ID is not in $\bar L$.   
 \begin{enumerate}
 \item\label{gen-unmaking-poly} computes polynomial $\bm\chi^{  {  {(D, C)}}}$ as follows. 
 %
 \vspace{-.2mm}
 %
 $$\bm\chi^{ \st {  {(D, C)}}}=\bm\zeta\cdot \bm\eta^{ \st {  {(D,C)}}}-(\bm\gamma^{ \st {  {(D,C)}}}+\bm\delta^{ \st {  {(D,C)}}})$$
 
 \vspace{-.3mm}
 
  where $\bm\eta^{ \st {  {(D,C)}}}$ is a fresh random polynomial of degree $3d+1$. 
  
  \item\label{send-unmaking-poly} sends  polynomial $\bm\chi^{ \st {  {(D, C)}}}$ to  $\mathcal{SC}_{\fpsi}$. 
  

 \end{enumerate}
  Note, if $\bar L$ contains all clients' IDs, then $D$ does not need to take the above steps \ref{gen-unmaking-poly} and \ref{send-unmaking-poly}. 
 %%%%%%%%%%%%%%%%%%%%%%
 
 \item  $\mathcal{SC}_{\fpsi}$,   takes the following steps to check if the client misbehaved,  for each bin of client $    {  C}$ whose ID is not in $\bar L$.
 
 %for each client $    {  C}$'s bin, takes the following steps to check if the client misbehaved.
 
  \begin{enumerate}
  
 \item computes  polynomial $\bm\iota^{\st  {  {(C)}}}$ as follows: 
 
 $\bm\iota^{ \st {  {(C)}}}=\bm\chi^{\st  {  {(D, C)}}}+\bm\nu^{\st  {  {(C)}}} +\bm\mu^{ \st {  {(C)}}}  
 =\bm\zeta\cdot(\bm\eta^{ \st {  {(D,C)}}} + \bm\omega^{ \st {  {(D,C)}}}\cdot \bm\omega^{ \st {  {(C,D)}}}\cdot \bm\pi^{ \st {  {(C)}}}+\bm\rho^{ \st {  {(D,C)}}}\cdot \bm\rho^{ \st {  {(C,D)}}}\cdot \bm\pi^{ \st {  {(D)}}}+\bm\xi^{ \st {  {(C)}}})$\\ 
%
%  \begin{equation*}
%\begin{split}
% \bm\iota^{ \st {  {(C)}}}&=\bm\chi^{\st  {  {(D, C)}}}+\bm\nu^{\st  {  {(C)}}} +\bm\mu^{ \st {  {(C)}}} \\ 
% &=\bm\zeta\cdot(\bm\eta^{ \st {  {(D,C)}}} + \bm\omega^{ \st {  {(D,C)}}}\cdot \bm\omega^{ \st {  {(C,D)}}}\cdot \bm\pi^{ \st {  {(C)}}}+\bm\rho^{ \st {  {(D,C)}}}\cdot \bm\rho^{ \st {  {(C,D)}}}\cdot \bm\pi^{ \st {  {(D)}}}+\bm\xi^{ \st {  {(C)}}})
% \end{split}
%\end{equation*}
%
 where $\bm\mu^{ \st {  {(C)}}} \in \vv{\mu}$ was sent to $\mathcal{SC}_{\fpsi}$  by \aud in step \ref{auditor}.   
  \item checks if $\bm\zeta$  divides $\bm\iota^{ \st {  {(C)}}}$. If the check fails, it appends the client's ID to  a list $ L'$.
  %
  \end{enumerate}
   If $\bar L$ contains all clients' IDs, then $\mathcal{SC}_{\fpsi}$ does not take the above two steps. 

 %
   \item  $\mathcal{SC}_{\fpsi}$  refunds the honest parties' deposit. Also, it retrieves the total amount of  $\chc$ from the deposit of dishonest clients (i.e., those clients whose IDs are in $\bar L$ or $L'$) and sends it to \aud.  It also splits the remaining deposit of the misbehaving parties among the honest ones. Thus, each honest client  receives $\yc+\chc+\frac{m'\cdot (\yc+\chc)-\chc}{m-m'}$ amount in total, where $m'$ is the total number of misbehaving parties.
 
 
%  \item  $\mathcal{SC}_{  {   {F-PSI}}}$  refunds the honest parties' deposit and splits the deposit of the misbehaving parties (i.e., those clients whose IDs are in $\bar L$ or $L'$)  among the honest ones. Thus, each honest party would receive $y+\frac{m'\cdot y}{m-m'}$ amount in total, where $m'$ is the total number of misbehaving parties.
 %%%%%%%%%%%%%%%%%%%%%
  \end{enumerate}
  
% \item If  $Flag=False$,  then $\mathcal{SC}_{  {   {F-PSI}}}$,  for each client $    {  C}$'s bin, takes the following steps:
% 
%  \begin{enumerate}
%  
% \item computes the following polynomial: 
% 
%  \begin{equation*}
%\begin{split}
% \bm\iota^{  {  {(C)}}}&=\bm\chi^{  {  {(D, C)}}}+\bm\nu^{  {  {(C)}}} \\ 
% &=\bm\zeta\cdot(\bm\eta^{  {  {(D,C)}}} + \bm\omega^{  {  {(D,C)}}}\cdot \bm\omega^{  {  {(C,D)}}}\cdot \bm\pi^{  {  {(C)}}}+\bm\rho^{  {  {(D,C)}}}\cdot \bm\rho^{  {  {(C,D)}}}\cdot \bm\pi^{  {  {(D)}}}+\bm\xi^{  {  {(C)}}})
% \end{split}
%\end{equation*}
% 
%  \item checks if $\bm\zeta$  divides $\bm\iota^{  {  {(C)}}}$. If does not, it appends the client's ID to a  list, $L$.
%  
%  \end{enumerate}
 
% \begin{equation*}
%\begin{split}
% \bm\iota^{  {  {(C)}}}&=\bm\zeta\cdot \bm\eta^{  {  {(D,C)}}}-(\bm\gamma^{  {  {(D,C)}}}+\bm\delta^{  {  {(D,C)}}})+\bm\nu^{  {  {(C)}}}-\sum\limits^{\st 3d+1}_{\st i=0}z_{\st i,c}\cdot x^{\st i} \\ &=\bm\zeta\cdot(\bm\eta^{  {  {(D,C)}}} + \bm\omega^{  {  {(D,C)}}}\cdot \bm\omega^{  {  {(C,D)}}}\cdot \bm\pi^{  {  {(C)}}}+\bm\rho^{  {  {(D,C)}}}\cdot \bm\rho^{  {  {(C,D)}}}\cdot \bm\pi^{  {  {(D)}}})
% \end{split}
%\end{equation*}
%  \item checks if $\bm\zeta$ can divide $\bm\iota^{  {  {(C)}}}$. If can not, it appends the client's ID to $L$.
% 
 

 
 
 
% \item Each client (given $\bm\zeta$ and $k_{\st 1}$), finds the elements in the intersection as follows. First, it derives a bin's pseudorandom polynomial: $\bm\gamma'$ from $k_{\st 1}$.  Next, it removes the blinding polynomial from each bin's polynomial: $\bm\phi'=\bm\phi-\bm\zeta\cdot \bm\gamma'$. Then, it evaluates each bin's unblinded polynomial at every  element belonging to that bin and considers the element in the intersection if the evaluation is zero: i.e. $\bm\phi'(s^{  {  {(I)}}}_{\st i})=0$
 
  \end{enumerate}
 
% the result: $cccc$ by locally evaluating the result polynomial: $\phi(x)$, at every  encrypted element, $e^{  {  {(I)}}}_{\st i}$, it has and considering the elements in the intersection if the following equation holds.  $\forall i, 1\leq i\leq d: \phi(e^{  {  {(I)}} }_{\st i})-\zeta(e^{  {  {(I)}}}_{\st i})\cdot \gamma'(e^{  {  {(I)}}}_{\st i})=0$.
 
 
 
%\begin{remark} After the Arbiter detects  misbehaving parties,  in step \ref{F-PSI:detect-misbehaving-party},  it sends their ID's to $\mathcal{SC}_{  {   {F-PSI}}}$ which refunds the honest parties' deposit and splits the misbehaving parties' deposit among the honest ones. Thus, each honest party would receive: $y+\frac{m'\cdot y}{m-m'}$ amount in total, where $m'$ is the total number of misbehaving parties.
% \end{remark}
 
 

%\begin{remark}

We refer readers to Appendix \ref{sec::Discussion-justitia} for a more in-depth discussion of $\withFai$ which encompasses (i) the inadequacy of strawman approaches such as using a server-aided PSI or charging the buyer a flat fee, (ii) instructions on how to eliminate the check in step \ref{JUS::check-non-zero-coeff}, (iii) an outline of the primary challenges we addressed during $\withFai$ design, and (iv) choice of concrete (security) parameters.  

Next, we present a theorem that formally states the security of \fpsi. 
 
 \vspace{-2mm}
 
 \begin{theorem}\label{theorem::F-PSI-security}
Let polynomials $\bm\zeta$, $\bm\omega$, and $\bm\gamma$ be three secret uniformly random polynomials. If  $\bm\theta=\bm\zeta\cdot \bm\omega\cdot\bm \pi+\bm \gamma \bmod p$ is an unforgeable polynomial (w.r.t. Theorem \ref{proof::unforgeable-poly}), \zspaa, \vopr,  $\mathtt{PRF}$, and smart contracts are secure, then \fpsi securely realises  $f^{\st \text{PSI}}$ with $Q$-fairness (w.r.t. Definition \ref{def::PSI-Q-fair}) in the presence of $m-1$  active-adversary clients (i.e., $A_{\st j}$s) or a passive dealer client, passive auditor, or passive public. 
 \end{theorem}
 

 \vspace{-2mm}

We refer readers to Appendix \ref{sec::F-PSI-proof} for the proof of Theorem \ref{theorem::F-PSI-security}. 



 
 