% !TEX root =main.tex


\vspace{-4.5mm}



\section{Other Subroutines Used in \withFai}\label{sec::subroutines}
\vspace{-1.4mm}

In this section, we present three subroutines and a primitive that we have developed and use in the instantiation of \p, known as \withFai. 


\vspace{-3mm}
\subsection{Verifiable Oblivious Polynomial Randomisation (\vopr)}\label{sec::vopr}
\vspace{-1.2mm}

%In this section, we present ``Verifiable Oblivious Polynomial Randomisation'' (VOPR) protocol. 

In the \vopr, two type of parties are involved, (i) a sender, potentially a passive adversary, and (ii) a receiver, potentially an active adversary. The protocol enables the receiver, with input polynomial $\bm\beta$ (of degree $e'$), and the sender, with input random polynomials $\bm\psi$ (of degree $e$) and  $\bm{\alpha}$ (of degree $e+e'$),   to compute: $\bm\theta=\bm\psi\cdot \bm\beta+\bm\alpha$, satisfying the following conditions: (a) the receiver learns only $\bm\theta$ and gains no knowledge of the sender's input even when setting $\bm \beta=0$, (b) the sender gains no knowledge, and (c) protocol detects the receiver's misbehavior.  Thus, the functionality that  \vopr computes is defined as $f^{\st {\vopr}}( (\bm\psi, \bm{\alpha}), \bm\beta)\rightarrow(\bot, \bm\psi\cdot \bm\beta+\bm\alpha)$. 

We will use {\vopr} in \withFai for two main purposes:  (a) to enable a party to re-randomise its counterpart's polynomial (representing its set) and (b) to impose a MAC-like structure on the randomised polynomial.  This structure will allow a verifier to detect any modifications to \vopr's output. 

Now, we will outline how we design \vopr without using any zero-knowledge proofs.\footnote{Previously, Ghosh \textit{et al.}  \cite{GhoshN19} designed a protocol called Oblivious Polynomial Addition (OPA) to meet similar security requirements that we laid out above. But, as shown in \cite{AbadiMZ21}, OPA  is susceptible to several serious attacks. } In the setup phase, both parties represent their input polynomials in the regular coefficient form; therefore, the sender's polynomials are defined as $\bm\psi=\sum\limits^{\st e}_{\st i=0}g_{\st i}\cdot x^{\st i}$ and  $\bm\alpha=\sum\limits^{\st e+e'}_{\st j=0}a_{\st j}\cdot x^{\st j}$ and the receiver's polynomial is defined as $\bm\beta=\sum\limits^{\st e'}_{\st i=0}b_{\st i}\cdot x^{\st i}$, where $b_{\st i}\neq 0$. However, the sender computes each coefficient $a_{\st j}$ (of polynomial $\bm \alpha$) as follows,  $a_{\st j}=\sum\limits^{\substack{\st k=e'\\ \st t=e}}_{\st t,k=0} a_{\st t,k}$,  where  $t+k=j$ and each $a_{\st t,k}$ is a random value. For instance, if $e=4$ and $e'=3$, then $a_{\st 3}=a_{\st \st 0,3}+a_{\st 3,0}+a_{\st 1,2}+a_{\st 2,1}$. Shortly, we explain why polynomial $\bm\alpha$ is constructed this way. 



In the computation phase,  to compute polynomial $\bm\theta$, the two parties interactively multiply and add the related coefficients in a secure way using $\ole^{\st +}$. Specifically,
%
%For simplicity, let $i=0$. 
%
for every $j$  (where $0\leq j\leq e'$) the sender sends $g_{\st i}$ and $a_{\st i,j}$ to an instance of  $\ole^{\st +}$, while the receiver sends $b_{\st j}$ to the same instance,  which returns $c_{\st i,j}=g_{\st i}\cdot b_{\st j}+ a_{\st i,j}$ to the receiver. This process is repeated for every $i$, where $0 \leq i \leq e$. Then, the receiver uses $c_{\st i,j}$ values to construct the resulting polynomial, $\bm\theta=\bm\psi\cdot \bm\beta+\bm\alpha$.  
%
The reason the sender imposes the above structure on (the coefficients of)  $\bm\alpha$ during the setup, is to enable the parties to securely compute $\bm\theta$ via  $\ole^{\st +}$. Specifically, by imposing this structure (1) the sender  can blind each product $g_{\st i}\cdot b_{\st j}$  with  random value $a_{\st i,j}$ which is a component of $\bm\alpha$'s coefficient and (2) the receiver can construct a result polynomial in the form $\bm\theta=\bm\psi\cdot \bm\beta+\bm\alpha$. 


To check the correctness of the result, the sender selects and transmits a random value $z$ to the receiver.  The receiver computes  $\bm\theta(z)$ and $\bm\beta(z)$ and sends these two values  to the sender. The sender computes  $\bm\psi(z)$ and $\bm\alpha(z)$ and then checks if equation  $\bm\theta({ z})=\bm\psi({ z})\cdot \bm\beta({ z})+\bm\alpha({ z})$ holds. It accepts the result if the check passes.   Figure \ref{fig:VOPR} describes \vopr in detail. 


\vspace{-6.3mm}
\input{VOPR}

Note that \vopr requires the sender to insert non-zero coefficients, i.e., $b_{\st i}\neq 0$ for all $i,0 \leq i \leq e'$. If the sender includes a zero-coefficient, then it will only obtain a random value (due to  $\ole^{\st +}$), making it fail to pass \vopr's verification phase. However, it is important to mention that this requirement does not affect the correctness of \withFai, as we will explain in Section \ref{Fair-PSI-Protocol} and Appendix \ref{sec::error-prob}.  

\vspace{-2mm}



%\vspace{-1mm}
\begin{theorem}\label{theorem::VOPR}
%
Let $f^{\st \vopr}$ be the functionality defined above. If the enhanced \ole (i.e., $\ole^{\st +}$) is secure against malicious (or active) adversaries, then the  Verifiable Oblivious Polynomial Randomisation (\vopr), presented in Figure \ref{fig:VOPR}, securely computes $f^{\st \vopr}$ in the presence of (i) semi-honest sender and honest receiver or (ii) malicious receiver and honest sender. 
%
\end{theorem}

\vspace{-1mm}
We refer readers to Appendix \ref{sec::proof-of-vopr} for the proof of Theorem \ref{theorem::VOPR}. 
\vspace{-1mm}

\input{ZSPA.tex}

%\input{Arbiter-algorithm}

\input{Arbiter-protocol.tex}