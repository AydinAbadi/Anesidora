% !TEX root =main.tex


\section{Further Discussion on \withRew}\label{sec::Discussion-Anesidora}
There is a simpler but costlier approach to finding the intersection without involving the extractors; that is the smart contract finds the (encoded) elements of the intersection and distributes the parties' deposit according to the number of elements it finds. This approach is simpler, as we do not need the involvement of (i) the extractors and (ii) the three counter collusion contracts. Nevertheless, it is costlier, because the contract itself needs to factorise the unblinded resulting polynomial and find the roots, which would cost it $O(d^{\st 2})$ for each bin, where $d$ is the size of each bin. Our proposed approach however moves such a computation off-chain, leading to a lower monetary computation cost. 
%\end{remark}



%\begin{remark}\label{remark::element-encoding}
The reason each client uses the hash-based padding to encode each encrypted element $e_{\st i}$  as $\bar{e}_{\st i} =e_{\st i} || \mathtt{H}(e_{\st i})$ is to allow the auditor in the counter collusion contracts to find the error-free intersection, without having to access to one of the original (encrypted) sets. 

Compared to \fpsi, there is a minor difference in finding the result in \epsi. Specifically, because in \epsi each set element  $s_{\st i}$ is encoded as  (i) $e_{\st i}=\mathtt{PRP}(mk', s_{\st i})$ and then (ii) $\bar{e}_{\st i} =e_{\st i} || \mathtt{H}(e_{\st i})$ by a client, then when the client wants to find the intersection it needs to first regenerate $\bar{e}_{\st i}$ as above and then treat it as a set element to check if  $\bm\phi'(\bar e_{\st i})=0$, in step \ref{F-PSI::find-intersection} of \fpsi.

%
%\end{remark}


%\begin{remark}
%The protocol requires  extractor clients  to commit to their encrypted set elements \emph{before} \epsi starts, to prevent the clients to find some random roots introduced in the result and sell them to the buyer. Furthermore, instead of the extractor's commitment scheme we proposed, one could  use polynomial commitment scheme \cite{Kate-poly-commit}. However, our scheme (tailored for our Smart PSI) is more efficient, as it is based on efficient symmetric key primitives; whereas, \cite{Kate-poly-commit} requires expensive public key and bilinear pairing operations. 
%\end{remark}

%\begin{remark}
%The Traitor's contract must be signed between the dealer and the extractor client who betrays the other colluding extractor or buyer  before step \ref{extractor-proves}. Also, the dealer pays the refundable deposits in the Traitor's contract. 
%
%\end{remark}




%\begin{remark}
%For ease of exposition, $\mathtt{ZSPA}$ protocol (in Fig \ref{fig:ZSPA}) was presented for single bin. However, it can easily be extended to multiple bins (using only two keys: $k_{\st 1}, k_{\st 2}$). To do so, for each bin $l$ (in step \ref{ZSPA:val-gen}) each blinding factor is computed as  $z_{\st i,j,l}=\mathtt{PRF}(k_{\st 1},i||j||l)$ and  the randomness of the commitment  is generated as: $ q_{\st i,j,l}=\mathtt{PRF}(k_{\st 2},i||j||l)$. Also, a Merkel tree is built on top of all bins' committed values that yields single root. 
%\end{remark}

%\begin{remark}
%Recall, when $Flag=False$, each honest party receives the total amount of $\frac{m'\cdot \yc'-\chc}{m-m'}$ amount from $\mathcal{SC}_{\fpsi}$ as compensation and reward.  
%\end{remark}


%\begin{remark} 
In \epsi, each extractor uses double-layered commitments (i.e., it first commits to the encryption of each element and then constructs a Merkle tree on top of all commitments) for efficiency and privacy purposes. Constructing a Merkle tree on top of the commitments allows the extractor to store only a single value in $\SCe$ would impose a much lower storage cost compared to the case where it would store all commitments in $\SCe$. Also, committing to the elements' encryption allows it to hide from other clients the encryption of those elements that are not in the intersection. Recall that encrypting each element is not sufficient to protect one client's elements from the rest of the clients, as they all know the decryption key. 


To increase their reward, malicious clients may be tempted to insert ``garbage'' elements into their sets with the hope that those garbage elements appear in the result and accordingly they receive a higher reward. However, they would not succeed as long as there exists a semi-honest client (e.g., dealer $D$) which uses actual set elements. In this case, by the set intersection definition, those garbage elements will not appear in the intersection. 


In \epsi, for the sake of simplicity, we let each party receive a fixed reward, i.e., $\lc$, for every element it contributes to the intersection. However, it is possible to make the process more flexible/generic. For instance, we could define a Reward Function $RF$ that takes $\lc$, an (encoded) set element $e_{\st i}$ in the intersection, its distribution/value $val_{\st e_{\st i}}$, and output a reward $rew_{\st e_{\st i}}$ that each party should receive for contributing that element to the intersection, i.e., $RF(\lc, e_{\st i}, val_{\st e_{\st i}})\rightarrow rew_{\st e_{\st i}}$. 