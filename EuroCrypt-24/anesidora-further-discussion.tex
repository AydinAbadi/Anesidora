% !TEX root =main.tex


%%%%%%%%%%%%%%%%%

\section{Further Discussion on \withRew}\label{sec::Discussion-Anesidora}



\subsection{Strawman Approach}


There is a simpler but more expensive approach to finding the intersection without the participation of the extractors. In this approach, the smart contract identifies the (encoded) elements of the intersection and distributes the parties' deposits based on the number of elements it discovers. While this method is simpler, as it eliminates the need for both (i) the involvement of the extractors and (ii) the three counter-collusion contracts, it comes at a higher cost.

This increased cost arises because the contract itself must factorise the unblinded resulting polynomial and locate the roots, incurring an $O(d^{\st 2})$ computational cost for each bin, where $d$ is the size of each bin. In contrast, our proposed approach offloads such computations off-chain, resulting in a lower monetary computation cost.

%\end{remark}


 
\subsection{Encrypting Set Elements}
In \epsi, each party initially encrypts its set elements (using deterministic encryption) to preserve the privacy of the elements from non-participants of the protocol, e.g., the public. This allows extractors to prove to the (public) smart contract $\SCe$ that they have already committed to the encryption of the elements in the intersection without revealing the actual plaintext elements. 


 
\subsection{The Use of the Hash-based Padding}
The reason each client uses the hash-based padding to encode each encrypted element $e_{\st i}$  as $\bar{e}_{\st i} =e_{\st i} || \mathtt{H}(e_{\st i})$ is to allow the auditor in the counter collusion contracts to find the error-free intersection, without having to access to one of the original (encrypted) sets. 



 
\subsection{Extracting the Elements in the Intersection}\label{sec::Extracting-Elements-in-Intersection}
Compared to \fpsi, there is a minor difference in finding the result in \epsi. Specifically, because in \epsi each set element  $s_{\st i}$ is encoded as  (i) $e_{\st i}=\mathtt{PRP}(mk', s_{\st i})$ and then (ii) $\bar{e}_{\st i} =e_{\st i} || \mathtt{H}(e_{\st i})$ by a client, then when the client wants to find the intersection it needs to first regenerate $\bar{e}_{\st i}$ as above and then treat it as a set element to check if  $\bm\phi'(\bar e_{\st i})=0$, in step \ref{F-PSI::find-intersection} of \fpsi. 

%
%\end{remark}


%\begin{remark}
%The protocol requires  extractor clients  to commit to their encrypted set elements \emph{before} \epsi starts, to prevent the clients to find some random roots introduced in the result and sell them to the buyer. Furthermore, instead of the extractor's commitment scheme we proposed, one could  use polynomial commitment scheme \cite{Kate-poly-commit}. However, our scheme (tailored for our Smart PSI) is more efficient, as it is based on efficient symmetric key primitives; whereas, \cite{Kate-poly-commit} requires expensive public key and bilinear pairing operations. 
%\end{remark}

%\begin{remark}
%The Traitor's contract must be signed between the dealer and the extractor client who betrays the other colluding extractor or buyer  before step \ref{extractor-proves}. Also, the dealer pays the refundable deposits in the Traitor's contract. 
%
%\end{remark}




%\begin{remark}
%For ease of exposition, $\mathtt{ZSPA}$ protocol (in Fig \ref{fig:ZSPA}) was presented for single bin. However, it can easily be extended to multiple bins (using only two keys: $k_{\st 1}, k_{\st 2}$). To do so, for each bin $l$ (in step \ref{ZSPA:val-gen}) each blinding factor is computed as  $z_{\st i,j,l}=\mathtt{PRF}(k_{\st 1},i||j||l)$ and  the randomness of the commitment  is generated as: $ q_{\st i,j,l}=\mathtt{PRF}(k_{\st 2},i||j||l)$. Also, a Merkel tree is built on top of all bins' committed values that yields single root. 
%\end{remark}

%\begin{remark}
%Recall, when $Flag=False$, each honest party receives the total amount of $\frac{m'\cdot \yc'-\chc}{m-m'}$ amount from $\mathcal{SC}_{\fpsi}$ as compensation and reward.  
%\end{remark}


%\begin{remark} 

\subsection{The Use of Double-layered Commitments}
In \epsi, each extractor employs double-layered commitments, which involves initially committing to the encryption of each element and subsequently constructing a Merkle tree on top of all these commitments. This approach is adopted for efficiency and privacy reasons.


Constructing a Merkle tree on top of the commitments enables the extractor to store just a single value in $\SCe$  resulting in significantly lower storage costs compared to the alternative scenario where all commitments would need to be stored in $\SCe$. Additionally, committing to the encryption of the elements allows the extractor to conceal from other clients the encryption of those elements that do not belong to the intersection. It is important to note that simply encrypting each element would not suffice to protect one client's elements from the other clients, as they all possess knowledge of the decryption key.





\subsection{Inserting Garbage Inputs}

To potentially increase their reward, malicious clients might be tempted to insert ``garbage'' elements into their sets,  hoping that these spurious elements will appear in the result, thus yielding a greater reward. However, their efforts would be in vain as long as a semi-honest client (such as dealer $D$) includes genuine set elements. In this scenario, according to the set intersection definition, those garbage elements will not be part of the intersection.




\subsection{Using Generic Reward Function}
In \epsi, for the sake of simplicity, we allowed each party receive a fixed reward, i.e., $\lc$, for every element it contributes to the intersection. It is possible to make the process more flexible/generic. For instance, we could define a Reward Function $RF$ that takes $\lc$, an (encoded) set element $e_{\st i}$ in the intersection, its distribution/value $val_{\st e_{\st i}}$, and output a reward $rew_{\st e_{\st i}}$ that each party should receive for contributing that element to the intersection, i.e., $RF(\lc, e_{\st i}, val_{\st e_{\st i}})\rightarrow rew_{\st e_{\st i}}$.





 