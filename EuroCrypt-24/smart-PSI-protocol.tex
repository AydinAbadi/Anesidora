% !TEX root =main.tex


%\section{Sub Protocols}


 \vspace{-2mm}

\section{Definition of Multi-party PSI with Fair Compensation and Reward}
 \vspace{-1mm}

In this section, we upgrade \p to ``multi-party PSI with Fair Compensation and Reward'' (\ep), which (in addition to offering the features of \p) lets honest clients who contribute their set receive a reward from a buyer who initiates the PSI computation. % and is interested in the result.


%In this section, we present the notion of ``Earn while You Reveal PSI'' (\ep), which allows honest clients who contribute their set to get paid by a buyer who initiates the PSI computation and is interested in the result. 

%In this section, we present an efficient  PSI that allows honest parties who contribute their set to get paid by a buyer who initiates the PSI computation and is interested in the result. 

%\subsection{The Model}

%In this section, we provide the security model of our smart-PSI protocol. There are two kind of parties involved in the protocol. Namely, (1) a set of clients $\{A_{\st 1},...,A_{\st m}\}$ potentially \emph{rational} (i.e. an adversary that picks the best strategy to maximise its profit) and all may collude with each other, and (2) a non- colluding dealer: client $D$, potentially semi-honest (i.e. a passive adversary).  Similar to F-PSI, we consider static adversary, we assume there is an authenticated private (off-chain) channel between the clients and we consider a standard public blockchain.
%  


In \ep, there are (1) a set of clients $\{A_{\st 1},...,A_{\st m}\}$ a subset of which can be active adversaries and may collude with each other, (2) a non-colluding dealer client, $D$, potentially semi-honest, and (3) an auditor $Aud$ potentially semi-honest, where all clients have input set. Also,   there are two ``extractor'' clients, say $A_{\st 1}$ and $A_{\st 2}$, where $(A_{\st 1},A_{\st 2})\in \{A_{\st 1},...,A_{\st m}\}$. These extractor clients volunteer to extract the (encoded) elements of the intersection and send them to a public bulletin board, i.e., a smart contract. In return, they will be paid. 
%
%We assume these two extractors are corrupted by an active adversary during interacting with other parties (and clients) until they collaborate with the rest of the clients to compute the intersection; 
%
We assume these two extractors act rationally only when they want to carry out the paid task of extracting the intersection and reporting it to the smart contract, so they can maximise their profit.\footnote{Thus, similar to any $A_{\st i}$ in \p, these extractors might be corrupted by an active adversary during the PSI computation.} For simplicity, we let client $A_{\st m}$ be the buyer, i.e., the party which initiates the PSI computation and is interested in the result. 


 The formal definition of \ep is built upon the definition of \p; nevertheless, in \ep, we ensure that honest non-buyer clients receive a \emph{reward} for participating in the protocol and revealing a portion of their inputs deduced from the result. We:  (i)  upgrade \qdel to  \qdelwr to ensure that when honest clients receive the result, an honest non-buyer client receives its deposit back plus a reward and a buyer client receives its deposit back minus the paid reward, and (ii) upgrade  \qUnFAbt to \qUnFAbtwr to ensure when an adversary aborts in an unfair manner, then an honest party receives its deposit back plus a predefined amount of compensation plus a reward.  Predicates  \qinit and \qFAbt remain unchanged. We denote the four predicates as $\bar Q:=(\qinit,  \qdelwr, \qUnFAbtwr, \qFAbt)$. We refer readers to Appendix \ref{sec::Formal-Definitions-of-E-PSI-Predicates} for formal definitions of predicates \qdelwr and \qUnFAbtwr. 
 
 
 
 
Next, we present the formal definition of  \ep. 


%%%%%%%%

 \vspace{-1mm}
\begin{definition}[\ep]\label{def::PSI-Q-fair-reward}
Let $f^{\st \text{PSI}}$ be the multi-party PSI functionality defined in Section \ref{sec::F-PSI-model}. Protocol $\Gamma$ realises  $f^{\st \text{PSI}}$ with $\bar Q$-fairness-and-reward in the presence of $m-3$ static active-adversary clients $A_{\st j}$s and $two$ rational clients $A_{\st i}s$ or a static passive dealer  $D$ or passive auditor $Aud$, if for every non-uniform PPT adversary $\mathcal{A}$ for the real model, there exists a non-uniform PPT adversary (or simulator) $\mathsf{Sim}$ for the ideal model, such that for every $I\in \{A_{\st 1},...,A_{\st m}, D, Aud\}$, it holds that: 
%\begin{equation*}
$\{\mathsf {Ideal}^{\st \mathcal{W}(f^{\st \text{PSI}}, \bar Q)}_{\st \mathsf{Sim}(z), I}(S_{\st 1},..., S_{\st m+1})\}_{\st S_{\st 1},..., S_{\st m+1},z}\stackrel{c}{\equiv} \{\mathsf{Real}_{\st \mathcal{A}(z), I}^{\st \Gamma}(S_{\st 1}\\,..., S_{\st m+1}) \}_{\st S_{\st 1},..., S_{\st m+1},z}$, 
%\end{equation*}
where  $z$ is an auxiliary input given to $\mathcal{A}$ and  $\mathcal{W}(f^{\st \text{PSI}}, \bar Q)$ is a functionality that wraps $f^{\st \text{PSI}}$ with predicates $\bar Q:=(\qinit,  \qdelwr, \qUnFAbtwr, \qFAbt)$. 
  \end{definition}



%%%%%%%%

 \vspace{-5mm}
\section{Concrete Construction of \ep}

 \vspace{-3mm}
 
 %%%%%%%%%%%


%%%%%%%%%%

%\subsubsection{Preserving the Intersection Privacy.} As stated above, the extractors are required to prove to a smart contract that they know 


\subsection{Description of \withRew (\epsi)}
 \vspace{-1mm}
%An Overview of E-PSI}

%This section presents a protocol, called E-PSI, that realises \ep. 




To construct  \epsi, we mainly use \fpsi, deterministic encryption, ``double-layered'' commitments, the hash-based padding technique, and the counter-collusion smart contracts. % (described in Section \ref{Counter-Collusion-Smart-Contracts}). 
%
At a high level, \epsi works as follows. First, all clients run step \ref{gen-FPSI-cont} of \fpsi to agree on a set of parameters and \fpsi's smart contract.  They deploy another smart contract, say $\SCe$. They also agree on a secret key, $mk'$. Next, the buyer places a certain deposit into $\SCe$. This deposit will be distributed among honest clients as a reward. 
%
%All clients check the buyer's deposit and proceed to the next step if they agree with the deposit amount.  
%
The extractors and $D$ deploy one of the counter-collusion smart contracts, i.e., \SCpc. These three parties deposit a certain amount on this contract.  Each honest extractor will receive a portion of $D$'s deposit for carrying out its task honestly and each dishonest extractor will lose a portion of its deposit for acting maliciously. 
%
Then, each client encrypts its set elements (under $mk'$ using deterministic encryption) and then represents the encrypted elements as a polynomial. %The reason each client encrypts its set elements is to ensure that the privacy of the plaintext elements in the intersection will be preserved from the public. 



%Then, each client represents the encryption of its set elements as a polynomial. 





%
Next, the extractors commit to the encryption of their set elements and publish the result. 
%
All clients (including $D$) take the rest of the steps in \fpsi using their input polynomials. This yields a blinded polynomial,  whose correctness is checked by \scf. 

If  \scf approves the result's correctness, then all parties receive their deposit put  in \scf. In this case, each extractor finds the set elements in the intersection. Each extractor proves to $\SCe$ that the encryptions of the elements in the intersection are among the commitments that the extractor previously published. 
%
If $\SCe$ accepts both extractors' proofs, then it pays each client (except the buyer) a reward, where the reward is taken from the buyer's deposit. The extractors receive their deposits back and are paid for carrying out the task honestly. Nevertheless, if $\SCe$ does not accept one of the extractors' proofs (or one extractor betrays the other), then it invokes the auditor in the counter-collusion contracts to identify the misbehaving extractor.  Then, $\SCe$ pays each honest client (except the buyer) a reward, taken from the misbehaving extractor. $\SCe$ also refunds the buyer's deposit.
%

If \scf does not approve the result's correctness and \aud identified misbehaving clients, then honest clients will receive (1) their deposit back from \fpsi's contract, and (2)  compensation and reward, taken from misbehaving clients. Moreover, the buyer and extractors receive their deposit back from $\SCe$. Figure \ref{fig:parties-interactions-in-ANE} in Appendix \ref{sec::Workflow-of-withRew} outlines the interaction between parties in \withRew. 














%However, we have to apply two essential modifications to F-PSI protocol. Generally speaking, the modifications are applied to (a) preserve the privacy of the elements in the intersection when each extractor proves the knowledge of them to the contract and (b) to identify misbehaving extractor without needing to have access to the extractor's set elements.  The role of collusion smart contracts is to create a distrust  between the extractors and buyer who may collude (out of the bound) to increase their profit.  

 \vspace{-3.4mm}
\subsection{Detailed Description of \epsi} 
 \vspace{-1mm}

Next, we describe the protocol in more detail (Table \ref{table:notation-table} in Appendix \ref{sec::notation-table} summarises the main notations used). 



%At a high level, two clients volunteer to be come result extractors.
%
%In the case of betray, an arbiter (potentially semi-honest) is invoked who can verify the claim of a betrayer and distribute the buyer payment among honest clients. In order for the arbiter to do so without having access to any clients input, the arbiter is required to find the intersection that requires it to find the roots of result polynomials and  be able to distinguish the error roots from actual encrypted set element. To this happen, we slightly modify the fair PSI protocol. In particular, in step \ref{encode-encrypt}, each client  $I\in \textbf{P}$ maps the elements of its set $S^{\st { {(I)}}}:\{ s^{\st { {(I)}}}_{\st 1},..., s^{\st { {(I)}}}_{\st d}\}$ to random values by encrypting them as follows. $\forall i, 1\leq i\leq d: e^{\st { {(I)}}}_{\st i}=\mathtt{PRP}(mk_{\st 2}, s^{\st { {(I)}}}_{\st i})$. Then, it encodes its encrypted set element as $ {e}^{\st { {(I)}}}_{\st i} =e^{\st { {(I)}}}_{\st i} || \mathtt{H}(e^{\st { {(I)}}}_{\st i})$.  After that, it constructs a hash table  $\mathtt{HT}^{\st { {(I)}}}$ and inserts the encrypted elements into the table. $\forall i: \mathtt{H}(  {e}_{\st i}^{\st { {(I)}}})={ {  {indx}}}$, then $  {e}^{\st { {(I)}}}_{\st i}\rightarrow \mathtt{HT}^{\st { {(I)}}}_{\st {  {indx}}}$. It pads every bin with random elements to $d$ elements (if needed). Then,  for every bin, it constructs a polynomial whose roots are  the bin's content: $\pi^{\st { {(I)}}}=\prod\limits^{\st c}_{\st i=1} (x-e'_{\st i})$, where $e'_{\st i}$ is either $ {e}^{\st {  {(I)} }}_{\st i}$, or a dummy value. 





\begin{enumerate}[leftmargin=4mm]

%\item All clients in $\textbf{P}$ sign a smart contract $\mathcal{SC}$ and deploy it to a blockchain. Then, the buyer, $ { A}_{\st {  m}}$, deposits $v$ amounts in the contract.

\item\label{e-psi::call-F-PSI-stepOne}  All clients in $\cl=\{ A_{\st 1},...,   A_{\st m},  D\}$ together run step \ref{gen-FPSI-cont} of \fpsi (in Section \ref{Fair-PSI-Protocol}) to deploy \fpsi's contract $\mathcal{SC}_{\fpsi}$ and agree on a  master key, $mk$. 

\item\label{e-psi::deploy-SC-E-PSI} All clients in $\cl$  deploy a new smart contract, $\SCe$. The address of $\SCe$ is given to all clients. 

\item Buyer $ { A}_{\st {  m}}$, before time $t_{\st 1}$, deposits $\Smin\cdot \vc$  amount to $\SCe$. 
\item\label{e-PSI::buyer-deposit} All clients after  time $t_{\st 2}>t_{\st 1}$ ensure that the buyer has deposited $\Smin\cdot \vc$ amount on $\SCe$. Otherwise, they abort.



\item\label{e-PSI::extractor-deposit} $D$ signs \SCpc with the extractors. $\SCe$ transfers $\Smin\cdot \rc$ amount (from the buyer deposit) to \SCpc for each extractor. This is the maximum amount to be paid to an honest extractor for honestly declaring the elements of the intersection. %Each honest extractor will be paid $\hat w'= r\cdot |{ { {S}}}_{\st\cap}|$, where 
%
Each extractor  deposits $\dc'=\dc+\Smin\cdot \fc$ amount in \SCpc at time $t_{\st 3}$. At time $t_{\st 4}$ all clients ensure that the extractors deposited enough coins; otherwise, they withdraw their deposit and abort. 

%
\item\label{e-psi::commit-to-mk} $D$ encrypts $mk$ under the public key of the dispute resolver (in \SCpc); let $ct_{\st mk}$ be the resulting ciphertext.  It also generates a commitment of $mk$ as follows: $z'=\mathtt{PRF}(mk, 0),\ com_{\st mk}=\comcom(mk, z')$. It stores $ct_{\st mk}$  and ${com}_{\st mk}$ in $\SCe$. 


\item\label{e-psi::gen-mk-prime} All clients in $\cl$ engage in \ct to agree on another key, $mk'$.
%
\item\label{Smart-PSI:encode-elem} Each client  in $\cl$ encrypts the elements of its set $S:\{ s_{\st 1},..., s_{\st c}\}$ as: $\forall i, 1\leq i\leq c: e_{\st i}=\mathtt{PRP}(mk', s_{\st i})$. 
%
Then, it encodes its encrypted set element as $\bar{e}_{\st i} =e_{\st i} || \mathtt{H}(e_{\st i})$.  
%
Next, it constructs a hash table  $\mathtt{HT}$ and inserts the encoded elements into the table. $\forall i: \mathtt{H}( \bar{e}_{\st i})={ {  {j}}}$, then $\bar{e}_{\st i}\rightarrow \mathtt{HT}_{\st {  {j}}}$. It pads every bin with random dummy elements to $d$ elements (if needed). Then,  for every bin, it builds a polynomial whose roots are the bin's content: $\bm\pi^{\st { {(I)}}}=\prod\limits^{\st d}_{\st i=1} (x-e'_{\st i})$, where $e'_{\st i}$ is either $\bar{e}_{\st i}$, or a dummy value. 




\item\label{merkel-tree-cons} Every extractor in $\{A_{\st 1}, A_{\st 2}\}$: 

\begin{enumerate}
%
%\item for each bin, derives a pseudorandom polynomial: $\gamma'_{\st {  {j}}}$, using key $mk$.
%
%\item for each bin, evaluates $\gamma'_{\st {  {j}}}$ at the encode set elements of that bin: $\gamma'_{\st {  {j,i}}}=\gamma'_{\st {  {j}}}(\bar{e}^{\st { {(I)}}}_{\st i})$.
\item\label{smart-PSI::commit-to-bin} for each $j$-th bin, commits to the bin's elements: $com_{\st{i,j}}=\comcom(e'_{\st i}, q_{\st i})$, where $q_{\st i}$ is a fresh randomness  used for the commitment and $e'_{\st i}$ is either $\bar{e}_{\st i}$, or a dummy value of the bin. %Thus, if the bin contains paddings, it  commits to the paddings too. 




%\item commits to every  encrypted element.  $\forall i, 1\leq i\leq d: \mathtt{a}^{\st { {(I)}}}_{\st i}=\mathtt{Com}(e^{\st { {(I)}}}_{\st i}, q^{\st { {(I)}}}_{\st i})$, where $q^{\st { {(I)}}}_{\st i}$ is a fresh randomness  used for the commitment.
\item  constructs a Merkel tree on top of all committed values: 

$\mkgen(com_{\st 1,1},...,com_{\st d,h})\rightarrow g$. %Let $\mathtt{MT}^{\st g}$ be a Merkel tree with a root node $g^{\st I}$. 
\item stores the Merkel tree's root $g$ in $\SCe$.
\end{enumerate}


\item\label{e-psi::invoke-remainer-F-PSI} All clients in $\cl$   run steps \ref{ZSPA}--\ref{compute-res-poly} of \fpsi, where each client now deposits (in the $\mathcal{SC}_{\fpsi}$) $\yc'$ amount where $\yc'>\Smin\cdot \vc+{\chc}$. Recall, at the end of step \ref{compute-res-poly}  of \fpsi for each $j$-th bin (i) a random polynomial $\bm\zeta$ is registered in $\mathcal{SC}_{\fpsi}$, (ii) a polynomial $\bm\phi$ (blinded by a random polynomial $\bm\gamma'$) is extracted by $\mathcal{SC}_{\fpsi}$, and (iii) $\mathcal{SC}_{\fpsi}$  checkes this polynomial's  correctness. If the latter check:

\begin{itemize}
\item[$\bullet$] passes (i.e., $Flag=True$), then all parties run step \ref{F-PSI::flag-is-true} of \fpsi (with a minor difference, see Appendix \ref{sec::Extracting-Elements-in-Intersection}).  In this case, each party receives $\yc'$ amount it deposited in $\mathcal{SC}_{\fpsi}$. They proceed to step \ref{smart-PSI::extractors} below.

\item[$\bullet$]  fails (i.e., $Flag=False$), then all parties run step \ref{F-PSI::flag-is-false}  of \fpsi. In this case,
 \aud is paid $\chc$ amount, and each honest party receives back its deposit, i.e., $\yc'$ amount. Also,  from the misbehaving parties' deposit  $\frac{m'\cdot \yc'-\chc}{m-m'}$ amount is sent to each honest client,  to reward and compensate the client $\Smin\cdot \lc$ and $\frac{m'\cdot \yc'-\chc}{m-m'}- \Smin\cdot \lc$ amounts respectively, where $m'$ is the total number of misbehaving parties.  Also, $\SCe$ returns to (a) the buyer its deposit (i.e., $\Smin\cdot \vc$ amount paid to $\SCe$), and (b) each extractor its deposit, i.e., $\dc'$ amount paid to \SCpc. Then, the protocol halts. 
\end{itemize}

\item\label{smart-PSI::extractors} Every extractor client: 
\begin{enumerate}

\item finds the elements in the intersection as follows. It encodes each of its set elements to get $\bar e_{\st i}$, as explained in step \ref{Smart-PSI:encode-elem}.  
%i.e.,  it first computes $e^{\st { {(I)}}}_{\st i}=\mathtt{PRP}(mk',s^{\st { {(I)}}}_{\st i})$ and then computes $\bar{e}^{\st { {(I)}}}_{\st i} =e^{\st { {(I)}}}_{\st i} || \mathtt{H}(e^{\st { {(I)}}}_{\st i})$.
%
% and then encodes it:   (i.e. $ {e}^{\st { {(I)}}}_{\st i} =e^{\st { {(I)}}}_{\st i} || \mathtt{H}(e^{\st { {(I)}}}_{\st i})$). 
 %
It determines to which bin the encrypted value belongs, i.e., ${ {  {j}}}=\mathtt{H}( \bar{e}_{\st i})$. It evaluates the resulting polynomial (for that bin) at the encrypted element. It considers the element in the intersection if the evaluation is zero, i.e., $\bm\phi( \bar{e}_{\st i})-\bm\zeta( \bar{e}_{\st i})\cdot \bm\gamma'( \bar{e}_{\st i})=0$. If the extractor is a traitor, by this step it should have signed \SCtc with $ { D}$ and provided related inputs to \SCtc. 

\item \label{extractor-proves} proves that every element in the intersection is among the elements it has committed to. Specifically, for each element in the intersection, say $\bar{e}_{\st i}$, it sends to $\SCe$: 



\begin{enumerate}
%
%\item [$\bullet$]  the opening of commitment $\mathtt{a}'$, i.e., pair $\ddot {x}:=(mk, z')$. This is done only once for all elements in the intersection.  
%
\item [$\bullet$]  commitment $com_{\st i,j}$ (generated in step \ref{smart-PSI::commit-to-bin}, for $\bar{e}_{\st i}$) and its  opening ${\hat x}':=(\bar{e}_{\st i},  q_{\st i})$. 


%
%\item [$\bullet$] the element's commitment: $\mathtt{a}^{\st { {(I)}}}_{\st {  {j,i}}}=\mathtt{Com}(\gamma'_{\st {  {j,i}}}, q^{\st { {(I)}}}_{\st i})$, where $q^{\st { {{(I)}}} }_{\st i}$ was generated in step \ref{merkel-tree-cons}.   
%
%\item[$\bullet$]  $ \bar{e}^{\st { {{(I)}}} }_{\st i}$ and it  commitment's opening:  $\mathtt{m}^{\st { {{(I)}}} }_{\st i}=(\gamma'_{\st {  {j,i}}}, q^{\st { {{(I)}}} }_{\st i})$. 

%
\item[$\bullet$]   proof $h_{\st i}$  asserting $com_{\st i,j}$ is a leaf node of   a Merkel tree with  root $g$. 

%\item[$\bullet$] the index of the bin to which $ \bar{e}^{\st { {{(I)}}} }_{\st i}$ belongs, i.e., ${ {  {j}}}=\mathtt{H}(\bar {e}^{\st { {{(I)}}} }_{\st i})$. 
 \end{enumerate}
\item sends the opening of $com_{\st mk}$, i.e., pair $\hat {x}:=(mk, z')$, to $\SCe$. This is done only once for all elements in the intersection.  

 \end{enumerate}
\item\label{e-psi::SC-verification} Contract $\SCe$:
%
\begin{enumerate}

\item\label{e-psi::SC-verification--derive-mk}  verifies the opening of the commitment for $mk$, i.e., $\comver(com_{\st mk},$ $\hat{x})=1$. If the verification passes, it generates the index of the bin to which $ \bar{e}_{\st i}$ belongs, i.e., ${ {  {j}}}=\mathtt{H}(\bar {e}_{\st i})$. It  uses $mk$ to derive the pseudorandom polynomial $\bm\gamma'$ for $j$-th bin. 


 \item\label{e-psi::SC-verification--check-three-vals} checks whether (i) the opening of commitment is valid,  (ii) the Merkle tree proof is valid, and (iii) the encrypted element is the resulting polynomial's root. Specifically, it ensures that the following relation holds: $\Big(\comver(com_{\st i,j}, \hat{x}')=1\Big) \hspace{0mm} \wedge \hspace{-0.5mm} \Big(\mkver(h_{\st i},g)=1\Big) \hspace{-.5mm} \wedge \hspace{0mm}  \Big(\bm\phi( \bar{e}_{\st i})-\bm\zeta( \bar{e}_{\st i})\cdot \bm\gamma'( \bar{e}_{\st i})=0\Big)$.


%$$\mathtt{Ver_{\st com}}(\mathtt{a}^{\st { {{(I)}}} }_{\st {  {j,i}}},\mathtt{m}^{\st { {{(I)}}} }_{\st i})=1\ \ \ \ \wedge \ \ \ \ \mathtt{Ver_{\st MT}}(\mathtt{h}^{\st { {{(I)}}} }_{\st i},g^{\st { {{(I)}}} })=1 \ \ \ \ \wedge \ \ \ \  \phi( \bar{e}^{\st { {{(I)}}} }_{\st i})-\zeta( \bar{e}^{\st { {{(I)}}} }_{\st i})\cdot \gamma'_{\st {  {j,i}}}=0$$

%\item if all proofs of both extractors are valid and both extractors provide identical elements of the intersections (for each bin),  for each valid proof, it takes $m\cdot l$ coins from the buyer's deposit (in $\mathcal{SC}_{\st {  {EXT}}}$) and distributes it among all clients, except the buyer. 

\end{enumerate}

\input{payment}

%\item Contract $\mathcal{SC}_{\st {  {EXT}}}$ after time $t_{\st 3}$ checks if $|{ { {S}}}_{\st\cap}|<{ { {S}}}_{\st {  min}}$. In this case, it returns $({ { {S}}}_{\st {  min}}-|{ { {S}}}_{\st\cap}|)\cdot v$ amount  to the buyer.

\end{enumerate}


 \vspace{-2.5mm}
 In Appendix \ref{sec::Annesidora-challenges}, we elaborate on the primary challenges we had to confront during the protocol design, which encompassed rewarding clients proportionately to the intersection size and managing collusions among extractors. Additionally, we direct readers to Appendix \ref{sec::Discussion-Anesidora} for a more comprehensive discussion of \withRew, where we elucidate why a naive approach is inadequate and provide insights into the use of hash-based padding and double-layered commitment.
 
 
 

 \vspace{-2mm}
 \begin{theorem}\label{theorem::E-PSI-security}
If  $\mathtt{PRP}$, $\mathtt{PRF}$, the commitment scheme, smart contracts, the Merkle tree scheme, \fpsi and the counter-collusion contracts are secure and the public key encryption is semantically secure,  then  \epsi realises  $f^{\st \text{PSI}}$ with $\bar Q$-fairness-and-reward (w.r.t. Definition \ref{def::PSI-Q-fair-reward}) in the presence of $m-3$ static active-adversary clients $A_{\st j}$s and $two$ rational clients $A_{\st i}s$ or a static passive dealer $D$ or passive auditor $Aud$, or passive public which sees the intersection cardinality.
 \end{theorem}

\vspace{-2mm}

We prove Theorem \ref{theorem::E-PSI-security} in Appendix \ref{sec::E-PSI-proof}. 




%%%%%%%%


%\end{remark}


%\begin{remark}
%The Merkle three is used to reduce the contract-side storage cost  each time an instance of the PSI is run. 
%
%\end{remark}


%\begin{remark}
% The reason smart PSI has a  verification mechanism for the extractors (instead of solely relying on the arbiter in the counter collusion contracts) is to minimise the role the arbiter, and let $\mathcal{SC}_{\epsi}$ resolve most of  dispute. 
%\end{remark}


%\begin{remark}
%In \epsi (unlike \fpsi), the intersection cardinality is revealed to the public. The clients can use padding to hide the exact number of elements. Specifically, all clients can agree on a set of elements and all insert them into their set in the setup phase. 
%\end{remark}

%\input{E-PSI-proof}



