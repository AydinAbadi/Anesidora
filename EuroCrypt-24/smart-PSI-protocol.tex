% !TEX root =main.tex


%\section{Sub Protocols}


 \vspace{-5mm}

\section{Definition of \ep}
 \vspace{-2mm}

In this section, we enhance \p to ``multi-party PSI with Fair Compensation and Reward'' (\ep), which not only provides the functionalities of \p,  but also allows honest clients contributing their set to receive a reward from the buyer who initiates the PSI computation.





%In this section, we present the notion of ``Earn while You Reveal PSI'' (\ep), which allows honest clients who contribute their set to get paid by a buyer who initiates the PSI computation and is interested in the result. 

%In this section, we present an efficient  PSI that allows honest parties who contribute their set to get paid by a buyer who initiates the PSI computation and is interested in the result. 

%\subsection{The Model}

%In this section, we provide the security model of our smart-PSI protocol. There are two kind of parties involved in the protocol. Namely, (1) a set of clients $\{A_{\st 1},...,A_{\st m}\}$ potentially \emph{rational} (i.e. an adversary that picks the best strategy to maximise its profit) and all may collude with each other, and (2) a non- colluding dealer: client $D$, potentially semi-honest (i.e. a passive adversary).  Similar to F-PSI, we consider static adversary, we assume there is an authenticated private (off-chain) channel between the clients and we consider a standard public blockchain.
%  


In \ep, there are (1) a set of clients $\{A_{\st 1},...,A_{\st m}\}$ within which a subset can potentially be active adversaries and engage in collusion, (2) a non-colluding dealer client, $D$, who may be semi-honest, and (3) an auditor $Aud$, who may also be semi-honest.  Every client possesses an input set. 


Moreover,  there are two ``extractor'' clients: $A_{\st 1}$ and $A_{\st 2}$, where $(A_{\st 1},A_{\st 2})\in \{A_{\st 1},...,A_{\st m}\}$.  These extractor clients voluntarily undertake the task of extracting the (encoded) elements of the intersection and transmitting them to a public bulletin board, represented by a smart contract. In exchange for this service, they will receive payment.
%
%We assume these two extractors are corrupted by an active adversary during interacting with other parties (and clients) until they collaborate with the rest of the clients to compute the intersection; 
%
We assume that these two extractors act rationally when they intend to perform the paid task of extracting the intersection and reporting it to the smart contract. This rational behaviour allows them to maximise their profit.\footnote{Thus, similar to any $A_{\st i}$ in \p, these extractors might be corrupted by an active adversary and act maliciousely during the PSI computation.} For simplicity, we designate client $A_{\st m}$ as the buyer, implying that this party initiates the PSI computation and holds an interest in the outcome.


 The formal definition of \ep is constructed based on the definition of \p. Nevertheless, in \ep, we ensure that honest non-buyer clients receive a \emph{reward} for their participation in the protocol and for disclosing a portion of their inputs derived from the outcome. We achieve this through two main upgrades:  (i)  we enhance \qdel to  \qdelwr to ensure that when honest clients receive the result, an honest non-buyer client receives its deposit back along with a reward, while a buyer client receives its deposit back minus the paid reward and (ii) we upgrade  \qUnFAbt to \qUnFAbtwr to ensure that when an adversary aborts in the protocol unfairly, an honest party receives its deposit back along with a predefined amount of compensation and a reward.  
 %
 Predicates  \qinit and \qFAbt remain unchanged. We denote these four predicates as $\bar Q:=(\qinit,  \qdelwr, \qUnFAbtwr, \qFAbt)$. 
 
 For formal definitions of \qdelwr and \qUnFAbtwr, please refer to Appendix \ref{sec::Formal-Definitions-of-E-PSI-Predicates} on page \pageref{sec::Formal-Definitions-of-E-PSI-Predicates}. 
 %
Next, we present the formal definition of  \ep. 


%%%%%%%%

 \vspace{-1mm}
\begin{definition}[\ep]\label{def::PSI-Q-fair-reward}
Let $f^{\st \text{PSI}}$ be the multi-party PSI functionality defined in Section \ref{sec::F-PSI-model}. Protocol $\Gamma$ realises  $f^{\st \text{PSI}}$ with $\bar Q$-fairness-and-reward in the presence of $m-3$ static active-adversary clients $A_{\st j}$s and $two$ rational clients $A_{\st i}s$ or a static passive dealer  $D$ or passive auditor $Aud$, if for every non-uniform PPT adversary $\mathcal{A}$ for the real model, there exists a non-uniform PPT adversary (or simulator) $\mathsf{Sim}$ for the ideal model, such that for every $I\in \{A_{\st 1},...,A_{\st m}, D, Aud\}$, it holds: 
%\begin{equation*}
$\{\mathsf {Ideal}^{\st \mathcal{W}(f^{\st \text{PSI}}, \bar Q)}_{\st \mathsf{Sim}(z), I}(S_{\st 1},..., S_{\st m+1})\}_{\st S_{\st 1},..., S_{\st m+1},z}\stackrel{c}{\equiv} \{\mathsf{Real}_{\st \mathcal{A}(z), I}^{\st \Gamma}(S_{\st 1},..., S_{\st m+1}) \}_{\st S_{\st 1},..., S_{\st m+1},z}$, \\
%\end{equation*}
where  $z$ is an auxiliary input given to $\mathcal{A}$ and  $\mathcal{W}(f^{\st \text{PSI}}, \bar Q)$ is a functionality that wraps $f^{\st \text{PSI}}$ with predicates $\bar Q:=(\qinit,  \qdelwr, \qUnFAbtwr, \qFAbt)$. 
  \end{definition}



%%%%%%%%

 \vspace{-6.3mm}
\section{Concrete Construction of \ep}

 \vspace{-2mm}
 
 %%%%%%%%%%%


%%%%%%%%%%

%\subsubsection{Preserving the Intersection Privacy.} As stated above, the extractors are required to prove to a smart contract that they know 

 \vspace{-1mm}
\subsection{Description of \withRew (\epsi)}
 \vspace{-1mm}
%An Overview of E-PSI}

%This section presents a protocol, called E-PSI, that realises \ep. 




To construct  \epsi, we mainly use \fpsi, deterministic encryption, ``double-layered'' commitments, the hash-based padding technique, and the counter-collusion smart contracts. % (described in Section \ref{Counter-Collusion-Smart-Contracts}). 
%
At a high level, \epsi works as follows. Initially, all clients execute step \ref{gen-FPSI-cont} of \fpsi to reach an agreement on a set of parameters and \fpsi's smart contract.  They also deploy another smart contract, denoted as $\SCe$, and agree on a secret key, $mk'$. 
%
Next, the buyer deposits a certain amount into $\SCe$. This deposit will be distributed among honest clients as a reward. 
%
%All clients check the buyer's deposit and proceed to the next step if they agree with the deposit amount.  

The extractors and $D$ deploy one of the counter-collusion smart contracts, namely \SCpc. These three parties contribute a specific sum to \SCpc.  Each honest extractor will receive a portion of $D$'s deposit for carrying out its task honestly, while each dishonest extractor will incur a penalty, causing a deduction from their deposit for engaging in malicious behaviour. 
%
Each client encrypts its set elements (under $mk'$ using deterministic encryption) and represents the encrypted elements as a polynomial. %The reason each client encrypts its set elements is to ensure that the privacy of the plaintext elements in the intersection will be preserved from the public. 



%Then, each client represents the encryption of its set elements as a polynomial. 





%

Following this, the extractors make a commitment to the encryption of their set elements and publicly disclose the outcome. Subsequently, all clients (including $D$) proceed with the remaining steps outlined in \fpsi using their input polynomials. This process results in the creation of a blinded polynomial, the correctness of which is verified by \scf. There will be two cases: 

\vspace{-2mm}
\begin{enumerate}[leftmargin=4.5mm]
\item If  \scf confirms the correctness of the result,  all parties receive the deposits they initially placed in \scf. In this case, each extractor finds the set elements in the intersection. Additionally, each extractor provides proof to $\SCe$ that the encryptions of the elements in the intersection match the commitments they previously published. If $\SCe$ accepts the proofs from both extractors, it compensates each client  with a reward. This reward is funded from the buyer's deposit. The extractors receive refunds of their deposits and are also remunerated for their honest execution of the task. 
%
However, should  $\SCe$ decline to accept one of the extractors' proofs (or if one extractor betrays the other), it then activates the auditor, specified in the counter-collusion contracts, to identify the misbehaving extractor. Subsequently, $\SCe$ pays a reward to each honest client, with the reward sourced from the misbehaving extractor's deposit. Also, $\SCe$ provides a refund of the buyer's deposit. 

\item If \scf does not approve the result's correctness and \aud identified misbehaving clients, honest clients will receive (1) their deposit back from \fpsi's contract, and (2)  compensation and reward, funded by the misbehaving clients. Also, the buyer and extractors will have their deposits refunded by $\SCe$. Figure \ref{fig:parties-interactions-in-ANE} in Appendix \ref{sec::Workflow-of-withRew}  illustrates the interaction among the parties in \withRew. 
\end{enumerate}













%However, we have to apply two essential modifications to F-PSI protocol. Generally speaking, the modifications are applied to (a) preserve the privacy of the elements in the intersection when each extractor proves the knowledge of them to the contract and (b) to identify misbehaving extractor without needing to have access to the extractor's set elements.  The role of collusion smart contracts is to create a distrust  between the extractors and buyer who may collude (out of the bound) to increase their profit.  

 \vspace{-4mm}
\subsection{Detailed Description of \epsi} 
 \vspace{-2.59mm}

Next, we will provide a more detailed description of the protocol (Table \ref{table:notation-table} on page \pageref{table:notation-table} summarises the main notations used). 


\vspace{-2.76mm}
\begin{enumerate}[leftmargin=4mm]

%\item All clients in $\textbf{P}$ sign a smart contract $\mathcal{SC}$ and deploy it to a blockchain. Then, the buyer, $ { A}_{\st {  m}}$, deposits $v$ amounts in the contract.

\item\label{e-psi::call-F-PSI-stepOne}  All clients in $\cl=\{ A_{\st 1},...,   A_{\st m},  D\}$ collectively initiate step \ref{gen-FPSI-cont} of \fpsi (in Section \ref{Fair-PSI-Protocol}) to deploy \fpsi's contract $\mathcal{SC}_{\fpsi}$ and agree on a  master key, $mk$. 

\item\label{e-psi::deploy-SC-E-PSI} All clients in $\cl$  deploy a new smart contract, $\SCe$. The address of $\SCe$ is given to all clients. 

\item Buyer $ { A}_{\st {  m}}$, before time $t_{\st 1}$, deposits $\Smin\cdot \vc$  amount to $\SCe$. 
\item\label{e-PSI::buyer-deposit} All clients after  time $t_{\st 2}>t_{\st 1}$ ensure that the buyer has deposited $\Smin\cdot \vc$ amount on $\SCe$. Otherwise, they halt.



\item\label{e-PSI::extractor-deposit} $D$ signs \SCpc with the extractors. $\SCe$ transfers $\Smin\cdot \rc$ amount (from the buyer's deposit) to \SCpc for each extractor. This is the maximum amount to be paid to an honest extractor for honestly declaring the elements of the intersection. %Each honest extractor will be paid $\hat w'= r\cdot |{ { {S}}}_{\st\cap}|$, where 
%
Each extractor  deposits $\dc'=\dc+\Smin\cdot \fc$ amount in \SCpc at time $t_{\st 3}$. At time $t_{\st 4}$ all clients ensure that the extractors deposited a sufficient amount of coins; otherwise, they withdraw their deposit and halt. 

%
\item\label{e-psi::commit-to-mk} $D$ encrypts $mk$ under the public key of the auditor (in \SCpc); let $ct_{\st mk}$ be the resulting ciphertext.  It also generates a commitment of $mk$ as follows: $z'=\mathtt{PRF}(mk, 0),\ com_{\st mk}=\comcom(mk, z')$. It stores $ct_{\st mk}$  and ${com}_{\st mk}$ in $\SCe$. 


\item\label{e-psi::gen-mk-prime} All clients in $\cl$ engage in \ct to agree on another key, $mk'$.
%
\item\label{Smart-PSI:encode-elem} Each client  in $\cl$ encrypts the elements of its set $S:\{ s_{\st 1},..., s_{\st c}\}$ as: $\forall i, 1\leq i\leq c: e_{\st i}=\mathtt{PRP}(mk', s_{\st i})$. 
%
Then, it encodes its encrypted set element as $\bar{e}_{\st i} =e_{\st i} || \mathtt{H}(e_{\st i})$.  
%
Next, it constructs a hash table  $\mathtt{HT}$ and inserts the encoded elements into the table. $\forall i: \mathtt{H}( \bar{e}_{\st i})={ {  {j}}}$, then $\bar{e}_{\st i}\rightarrow \mathtt{HT}_{\st {  {j}}}$. It pads every bin with random dummy elements to $d$ elements (if needed). Then,  for every bin, it builds a polynomial whose roots are the bin's content: $\bm\pi^{\st { {(I)}}}=\prod\limits^{\st d}_{\st i=1} (x-e'_{\st i})$, where $e'_{\st i}$ is either $\bar{e}_{\st i}$, or a dummy value. 




\item\label{merkel-tree-cons} Every extractor in $\{A_{\st 1}, A_{\st 2}\}$: 

\begin{enumerate}
%
%\item for each bin, derives a pseudorandom polynomial: $\gamma'_{\st {  {j}}}$, using key $mk$.
%
%\item for each bin, evaluates $\gamma'_{\st {  {j}}}$ at the encode set elements of that bin: $\gamma'_{\st {  {j,i}}}=\gamma'_{\st {  {j}}}(\bar{e}^{\st { {(I)}}}_{\st i})$.
\item\label{smart-PSI::commit-to-bin} for each $j$-th bin, commits to the bin's elements: $com_{\st{i,j}}=\comcom(e'_{\st i}, q_{\st i})$, where $q_{\st i}$ is a fresh randomness  used for the commitment and $e'_{\st i}$ is either $\bar{e}_{\st i}$, or a dummy value of the bin. %Thus, if the bin contains paddings, it  commits to the paddings too. 




%\item commits to every  encrypted element.  $\forall i, 1\leq i\leq d: \mathtt{a}^{\st { {(I)}}}_{\st i}=\mathtt{Com}(e^{\st { {(I)}}}_{\st i}, q^{\st { {(I)}}}_{\st i})$, where $q^{\st { {(I)}}}_{\st i}$ is a fresh randomness  used for the commitment.
\item  constructs a Merkle tree on top of all committed values: 
\vspace{-.1mm}
$$\mkgen(com_{\st 1,1},...,com_{\st d,h})\rightarrow g$$ %Let $\mathtt{MT}^{\st g}$ be a Merkel tree with a root node $g^{\st I}$. 
\item stores the Merkle tree's root $g$ in $\SCe$.
\end{enumerate}


\item\label{e-psi::invoke-remainer-F-PSI} All clients in $\cl$   run steps \ref{ZSPA}--\ref{compute-res-poly} of \fpsi, where each client now deposits (in the $\mathcal{SC}_{\fpsi}$) $\yc'$ amount where $\yc'>\Smin\cdot \vc+{\chc}$. Recall, at the end of step \ref{compute-res-poly}  of \fpsi for each $j$-th bin (i) a random polynomial $\bm\zeta$ is registered in $\mathcal{SC}_{\fpsi}$, (ii) a polynomial $\bm\phi$ (blinded by a random polynomial $\bm\gamma'$) is extracted by $\mathcal{SC}_{\fpsi}$, and (iii) $\mathcal{SC}_{\fpsi}$  checkes this polynomial's  correctness. If the latter check:

\begin{itemize}
\item[$\bullet$] passes (i.e., $Flag=True$), then all parties run step \ref{F-PSI::flag-is-true} of \fpsi (with a minor difference, see Appendix \ref{sec::Extracting-Elements-in-Intersection}).  In this case, each party receives $\yc'$ amount it deposited in $\mathcal{SC}_{\fpsi}$. They proceed to step \ref{smart-PSI::extractors} below.

\item[$\bullet$]  fails (i.e., $Flag=False$), then all parties run step \ref{F-PSI::flag-is-false}  of \fpsi. 
 \aud is paid $\chc$ amount, and each honest party receives back its deposit, i.e., $\yc'$ amount. Also,  from the misbehaving parties' deposit  $\frac{m'\cdot \yc'-\chc}{m-m'}$ amount is sent to each honest client,  to reward and compensate the client $\Smin\cdot \lc$ and $\frac{m'\cdot \yc'-\chc}{m-m'}- \Smin\cdot \lc$ amounts respectively, where $m'$ is the total number of misbehaving parties.  Also, $\SCe$ returns to (a) the buyer its deposit (i.e., $\Smin\cdot \vc$ amount initially paid to $\SCe$), and (b) each extractor its deposit, i.e., $\dc'$ amount initially paid to \SCpc. Then, the protocol halts. 
\end{itemize}

\item\label{smart-PSI::extractors} Every extractor client: 
\begin{enumerate}

\item finds the elements in the intersection as follows. It encodes each of its set elements to obtain $\bar e_{\st i}$, as explained in step \ref{Smart-PSI:encode-elem}.  
%i.e.,  it first computes $e^{\st { {(I)}}}_{\st i}=\mathtt{PRP}(mk',s^{\st { {(I)}}}_{\st i})$ and then computes $\bar{e}^{\st { {(I)}}}_{\st i} =e^{\st { {(I)}}}_{\st i} || \mathtt{H}(e^{\st { {(I)}}}_{\st i})$.
%
% and then encodes it:   (i.e. $ {e}^{\st { {(I)}}}_{\st i} =e^{\st { {(I)}}}_{\st i} || \mathtt{H}(e^{\st { {(I)}}}_{\st i})$). 
 %
It determines to which bin the encrypted value belongs, i.e., ${ {  {j}}}=\mathtt{H}( \bar{e}_{\st i})$. It evaluates the resultant polynomial (for that bin) at the encrypted element and considers the element in the intersection if the evaluation is zero: $\bm\phi( \bar{e}_{\st i})-\bm\zeta( \bar{e}_{\st i})\cdot \bm\gamma'( \bar{e}_{\st i})=0$. If the extractor is a traitor, by this step it should have signed the traitorâ€™s contract \SCtc with $ { D}$ and provided related inputs to \SCtc. 

\item \label{extractor-proves} proves that every element in the intersection is among the elements it has committed to. Specifically, for each element in the intersection, for example $\bar{e}_{\st i}$, it sends to $\SCe$: 


\vspace{-1mm}
\begin{enumerate}
%
%\item [$\bullet$]  the opening of commitment $\mathtt{a}'$, i.e., pair $\ddot {x}:=(mk, z')$. This is done only once for all elements in the intersection.  
%
\item [$\bullet$]  commitment $com_{\st i,j}$ (generated in step \ref{smart-PSI::commit-to-bin}, for $\bar{e}_{\st i}$) and its  opening:
\vspace{-.1mm}
 $${\hat x}':=(\bar{e}_{\st i},  q_{\st i})$$ 


%
%\item [$\bullet$] the element's commitment: $\mathtt{a}^{\st { {(I)}}}_{\st {  {j,i}}}=\mathtt{Com}(\gamma'_{\st {  {j,i}}}, q^{\st { {(I)}}}_{\st i})$, where $q^{\st { {{(I)}}} }_{\st i}$ was generated in step \ref{merkel-tree-cons}.   
%
%\item[$\bullet$]  $ \bar{e}^{\st { {{(I)}}} }_{\st i}$ and it  commitment's opening:  $\mathtt{m}^{\st { {{(I)}}} }_{\st i}=(\gamma'_{\st {  {j,i}}}, q^{\st { {{(I)}}} }_{\st i})$. 

%
\item[$\bullet$]   proof $h_{\st i}$  asserting $com_{\st i,j}$ is a leaf node of   a Merkle tree with  root $g$. 

%\item[$\bullet$] the index of the bin to which $ \bar{e}^{\st { {{(I)}}} }_{\st i}$ belongs, i.e., ${ {  {j}}}=\mathtt{H}(\bar {e}^{\st { {{(I)}}} }_{\st i})$. 
 \end{enumerate}
\item sends the opening of $com_{\st mk}$, i.e., pair $\hat {x}:=(mk, z')$, to $\SCe$. This is done only once for all elements in the intersection.  

 \end{enumerate}
\item\label{e-psi::SC-verification} Contract $\SCe$:
%
\begin{enumerate}

\item\label{e-psi::SC-verification--derive-mk}  verifies the opening of the commitment for $mk$, i.e., $\comver(com_{\st mk},$ $\hat{x})=1$. If the verification passes, it generates the index of the bin to which $ \bar{e}_{\st i}$ belongs, i.e., ${ {  {j}}}=\mathtt{H}(\bar {e}_{\st i})$. It  uses $mk$ to derive the pseudorandom polynomial $\bm\gamma'$ for $j$-th bin. 


 \item\label{e-psi::SC-verification--check-three-vals} checks whether (i) the opening of commitment is valid,  (ii) the Merkle tree proof is valid, and (iii) the encrypted element is the resulting polynomial's root. Specifically, it ensures that the following relation holds: $\Big(\comver(com_{\st i,j}, \hat{x}')=1\Big) \hspace{0mm} \wedge \hspace{-0.5mm} \Big(\mkver(h_{\st i},g)=1\Big) \hspace{-.5mm} \wedge \hspace{0mm}  \Big(\bm\phi( \bar{e}_{\st i})-\bm\zeta( \bar{e}_{\st i})\cdot \bm\gamma'( \bar{e}_{\st i})=0\Big)$


%$$\mathtt{Ver_{\st com}}(\mathtt{a}^{\st { {{(I)}}} }_{\st {  {j,i}}},\mathtt{m}^{\st { {{(I)}}} }_{\st i})=1\ \ \ \ \wedge \ \ \ \ \mathtt{Ver_{\st MT}}(\mathtt{h}^{\st { {{(I)}}} }_{\st i},g^{\st { {{(I)}}} })=1 \ \ \ \ \wedge \ \ \ \  \phi( \bar{e}^{\st { {{(I)}}} }_{\st i})-\zeta( \bar{e}^{\st { {{(I)}}} }_{\st i})\cdot \gamma'_{\st {  {j,i}}}=0$$

%\item if all proofs of both extractors are valid and both extractors provide identical elements of the intersections (for each bin),  for each valid proof, it takes $m\cdot l$ coins from the buyer's deposit (in $\mathcal{SC}_{\st {  {EXT}}}$) and distributes it among all clients, except the buyer. 

\end{enumerate}

\input{payment}

%\item Contract $\mathcal{SC}_{\st {  {EXT}}}$ after time $t_{\st 3}$ checks if $|{ { {S}}}_{\st\cap}|<{ { {S}}}_{\st {  min}}$. In this case, it returns $({ { {S}}}_{\st {  min}}-|{ { {S}}}_{\st\cap}|)\cdot v$ amount  to the buyer.

\end{enumerate}


 \vspace{-3mm}
 In Appendix \ref{sec::Annesidora-challenges}, we elaborate on the primary challenges we had to confront during the protocol design, which encompassed rewarding clients proportionately to the intersection size and managing collusions among extractors. Additionally, we direct readers to Appendix \ref{sec::Discussion-Anesidora} for a more comprehensive discussion of \withRew, where we elucidate why a naive approach is inadequate and provide insights into the use of hash-based padding, encryption, and double-layered commitment.
 
 
 

 \vspace{-2.5mm}
 \begin{theorem}\label{theorem::E-PSI-security}
If  $\mathtt{PRP}$, $\mathtt{PRF}$, the commitment scheme, smart contracts, the Merkle tree scheme, \fpsi and the counter-collusion contracts are secure and the public key encryption is semantically secure,  then  \epsi realises  $f^{\st \text{PSI}}$ with $\bar Q$-fairness-and-reward (w.r.t. Definition \ref{def::PSI-Q-fair-reward}) in the presence of $m-3$ static active-adversary clients $A_{\st j}$s and $two$ rational clients $A_{\st i}s$ or a static passive dealer $D$ or passive auditor $Aud$, or passive public which sees the intersection cardinality.
 \end{theorem}

\vspace{-2mm}

We prove Theorem \ref{theorem::E-PSI-security} in Appendix \ref{sec::E-PSI-proof}. 

\vspace{-1mm}


%%%%%%%%


%\end{remark}


%\begin{remark}
%The Merkle three is used to reduce the contract-side storage cost  each time an instance of the PSI is run. 
%
%\end{remark}


%\begin{remark}
% The reason smart PSI has a  verification mechanism for the extractors (instead of solely relying on the arbiter in the counter collusion contracts) is to minimise the role the arbiter, and let $\mathcal{SC}_{\epsi}$ resolve most of  dispute. 
%\end{remark}


%\begin{remark}
%In \epsi (unlike \fpsi), the intersection cardinality is revealed to the public. The clients can use padding to hide the exact number of elements. Specifically, all clients can agree on a set of elements and all insert them into their set in the setup phase. 
%\end{remark}

%\input{E-PSI-proof}



