% !TEX root =main.tex

\subsection{Zero-sum Pseudorandom Values Agreement Protocol (\zspa)}

The \zspa  allows $m$ parties (the majority of which is potentially malicious) to efficiently agree on (a set of vectors, where each $i$-th vector has) $m$ pseudorandom values such that their sum equals zero. At a high level, the parties first sign a smart contract, register their accounts/addresses in it, and then run a  coin-tossing protocol \ct to agree on a key: $k$.  Next, one of the parties generates $m-1$ pseudorandom values $z_{\scriptscriptstyle i, j}$ (where $1\leq j\leq m-1$) using key $k$ and $\mathtt{PRF}$. It sets the last value as the additive inverse of the sum of the values generated, i.e. $z_{\scriptscriptstyle i, m}=-\sum\limits^{\scriptscriptstyle m-1}_{\scriptscriptstyle j=1}z_{\scriptscriptstyle i, j}$ (similar to the standard XOR-based secret sharing \cite{Schneier0078909}). 
%
%Next, it commits to each value, where it uses $k_{\scriptscriptstyle 2}$ to generate the randomness of each commitment. 
%
Then, it constructs a Merkel tree on top of the pseudorandom values and stores only the tree's root $g$ and the key's hash value $q$ in the smart contract.  Then, each party (using the key) locally checks if the values (on the contract) have been constructed correctly; if so, then it sends a (signed) ``approved" message to the contract which only accepts messages from registered parties. Hence, the functionality that \zspa computes is defined as $f^{\st \zspa}\underbrace{(\bot,..., \bot)}_{\st m}\rightarrow \underbrace{((k, g, q),..., (k, g,q))}_{\st m}$, where $g$ is the Markle tree's root built on the pseudorandom values $z_{\st i, j}$, $q$ is the hash value of the key used to generate the pseudorandom values, and $m\geq 2$. Figure \ref{fig:ZSPA} presents \zspa in detail.  


Briefly, \zspa will be used in \withFai to allow clients $\{A_{\st 1},...,A_{\st m}\}$ to provably agree on a set of pseudorandom values, where each set represents a pseudorandom polynomial (as the elements of the set are considered the polynomial's coefficients). Due to \zspa's property, the sum of these polynomials is zero.  Each of these polynomials will be used by a client to blind/encrypt the messages it sends to the smart contract, to protect the privacy of the plaintext message (from \aud, D, and the public). To compute the sum of the plaintext messages, one can easily sum the blinded messages, which removes the blinding polynomials. 

\input{ZSPA-protocol}

\begin{theorem}\label{theorem::ZSPA-comp-correctness}
Let $f^{\st \zspa}$ be the functionality defined above. If \ct is secure against a malicious adversary and the correctness of $\mathtt{PRF}$, $\mathtt{H}$, and Merkle tree holds, then \zspa,  in Figure \ref{fig:ZSPA}, securely computes $f^{\st \zspa}$ in the presence of $m-1 $ malicious  adversaries. 
\end{theorem}


\begin{proof}
For the sake of simplicity, we will assume the sender, which generates the result, sends the result directly to the rest of the parties, i.e., receivers, instead of sending it to a smart contract. We first consider the case in which the sender is corrupt. 

\

\noindent\textbf{Case 1: Corrupt sender.}  Let $\mathsf{Sim}^{\st \zspa}_{\st S}$ be the simulator using a subroutine adversary, $\mathcal{A}_{\st S}$. $\mathsf{Sim}^{\st \zspa}_{\st S}$ works as follows. 
%
\begin{enumerate}
%
\item simulates  \ct  and receives the output value $k$ from $f_{\st \ct}$, as we are in $f_{\st \ct}$-hybrid model.
%
\item sends $k$ to TTP and receives back from it $m$ pairs, where each pair is of the form $( g,  q)$. 
%
\item sends $ k$ to $\mathcal{A}_{\st S}$ and receives back from it $m$ pairs  where each pair is of the form $( g',  q')$. 
%
\item checks whether the following equations hold (for each pair): $ g= g' \hspace{2mm} \wedge  \hspace{2mm}  q= q'$. If the two equations do not hold, then it aborts (i.e., sends abort signal $\Lambda$ to the receiver) and proceeds to the next step.
%
\item outputs whatever $\mathcal{A}_{\st S}$ outputs.
%
 \end{enumerate}
 
 We first focus on the adversary’s output. In the real model, the only messages that the adversary receives are those messages it receives as the result of the ideal call to $f_{\st \ct}$. These messages have identical distribution to the distribution of the messages in the ideal model, as the \ct is secure. Now, we move on to the receiver’s output. We will show that the output distributions of the honest receiver in the ideal and real models are computationally indistinguishable. In the real model,  each element of pair $(g, p)$ is the output of a deterministic function on the output of $f_{\st \ct}$. We know the output of $f_{\st \ct}$ in the real and ideal models have an identical distribution, and so do the evaluations of deterministic functions (i.e., Merkle tree, $\mathtt{H}$, and $\mathtt{PRF}$) on them, as long as these three functions' correctness holds. Therefore, each pair $(g,q)$ in the real model has an identical distribution to pair $(g,  q)$ in the ideal model.  For the same reasons, the honest receiver in the real model aborts with the same probability as  $\mathsf{Sim}^{\st \zspa}_{\st S}$ does in the ideal model.  We conclude that the distributions of the joint outputs of the adversary and honest receiver in the real and ideal models are  (computationally) indistinguishable. 

\


\noindent\textbf{Case 2: Corrupt receiver.}   Let $\mathsf{Sim}^{\st \zspa}_{\st R}$ be the simulator that uses subroutine adversary $\mathcal{A}_{\st R}$. $\mathsf{Sim}^{\st \zspa}_{\st R}$ works as follows. 

\begin{enumerate}
%
\item simulates   \ct  and receives the output value $ k$ from $f_{\st \ct}$.
%
\item sends $ k$ to TTP and receives back $m$ pairs of the form $( g,  q)$ from TTP. 
%
\item sends $( k,  g,  q)$ to $\mathcal{A}_{\st R}$ and outputs whatever  $\mathcal{A}_{\st R}$ outputs. 
%
 \end{enumerate}
 
 
In the real model, the adversary receives two sets of messages, the first set includes the transcripts (including $ k$) it receives when it makes an ideal call to $f_{\st \ct}$ and the second set includes pair $(g, q)$. As we already discussed above (because we are in the  $f_{\st \ct}$-hybrid model) the distributions of the messages it receives from $f_{\st \ct}$ in the real and ideal models are identical. Moreover, the distribution of $f_{\st \ct}$'s output (i.e., $\bar k$ and $k$) in both models is identical; therefore, the honest sender's output distribution in both models is identical. As we already discussed,  the evaluations of deterministic functions (i.e., Merkle tree, $\mathtt{H}$, and $\mathtt{PRF}$) on $f_{\st \ct}$'s outputs have an identical distribution. Therefore, each pair $(g, q)$ in the real model has an identical distribution to the pair $(g, q)$ in the ideal model.  Hence, the distribution of the joint outputs of the adversary and honest receiver in the real and ideal models is indistinguishable.
%
  \hfill\(\Box\)\end{proof}

In addition to the security guarantee (i.e., computation's correctness against malicious sender or receiver) stated by Theorem \ref{theorem::ZSPA-comp-correctness}, \zspa offers  (a) privacy against the public, and (b)  non-refutability. Informally, privacy here means that given the state of the contract (i.e., $g$ and  $q$), an external party cannot learn any information about any of the pseudorandom values,  $z_{\scriptscriptstyle j}$; while non-refutability means that if a party sends ``approved" then in future cannot deny the knowledge of the values whose representation is stored in the contract. %Furthermore, indistinguishability means that every $z_{\scriptscriptstyle j}$ ($1\leq j \leq m$) should be indistinguishable from a truly random value. 




\begin{theorem}
If  $\mathtt{H}$ is preimage resistance, $\mathtt{PRF}$ is secure, the signature scheme used in the smart contract is secure (i.e., existentially unforgeable under chosen message attacks), and the blockchain is secure (i.e., offers persistence and liveness properties \cite{GarayKL15}) then \zspa offers (i) privacy against the public and (ii) non-refutability. 
\end{theorem}
 
 

\begin{proof}
First, we focus on privacy. Since key $k$, for $\mathtt{PRF}$, has been picked uniformly at random and $\mathtt{H}$ is preimage resistance, the probability that given $g$ the adversary can find $k$ is negligible in the security parameter, i.e., $\negl(\lambda)$. Furthermore, because $\mathtt{PRF}$ is secure (i.e., its outputs are indistinguishable from random values) and  $\mathtt{H}$ is preimage resistance, given the Merkle tree's root $g$, the probability that the adversary can find a leaf node, which is the output of $\mathtt{PRF}$, is $\negl(\lambda)$ too. 

Now we move on the non-refutability. Due to the persistency property of the blockchain, once a transaction/message goes more than $v$ blocks deep into the blockchain of one honest player (where $v$ is a security parameter), then it will be included in every honest player's blockchain with overwhelming probability, and it will be assigned a permanent
position in the blockchain (so it will not be modified with an overwhelming probability). Also, due to the liveness property,   all transactions originating from honest parties will eventually end up at a depth of more than $v$ blocks in an honest player's blockchain; therefore, the adversary cannot
perform a selective denial of service attack against honest account holders.  Moreover, due to the security of the digital signature (i.e., existentially unforgeable under chosen message attacks), one cannot deny sending the messages it sent to the blockchain and smart contract. 
%
\hfill\(\Box\)
\end{proof}



%
%
%\begin{theorem}
%If  $\mathtt{H}$ is preimage resistance, $\mathtt{PRF}$ is secure, the signature scheme used in the smart contract is secure (i.e., existentially unforgeable under chosen message attacks), and the blockchain is secure (i.e., offers liveness property and the hash power of the adversary is lower than those of honest miners) then \zspa offers (i) privacy against the public and (ii) non-refutability. 
%\end{theorem}
% 
% 
%
%\begin{proof}
%First, we focus on privacy. Since key $k$, for $\mathtt{PRF}$, has been picked uniformly at random and $\mathtt{H}$ is preimage resistance, the probability that given $g$ the adversary can find $k$ is negligible in the security parameter, i.e., $\negl(\lambda)$. Furthermore, because $\mathtt{PRF}$ is secure (i.e., its outputs are indistinguishable from random values) and  $\mathtt{H}$ is preimage resistance, given the Merkle tree's root $g$, the probability that the adversary can find a leaf node, which is the output of $\mathtt{PRF}$, is $\negl(\lambda)$ too. 
%  \hfill\(\Box\)\end{proof}




%Informally, there are four main security requirements that ZSPA must meet: (a) privacy, (b)  non-refutability, (c) indistinguishability, and (d) result correctness. Privacy here means given the state of the contract, an external party cannot learn any information about any of the (pseudorandom) values:  $z_{\scriptscriptstyle j}$; while non-refutability means that if a party sends ``approved" then in future cannot deny the knowledge of the values whose representation is stored in the contract. Furthermore, indistinguishability means that every $z_{\scriptscriptstyle j}$ ($1\leq j \leq m$) should be indistinguishable from a truly random value and result correctness means that a malicious result generator cannot convince other parties to accept an invalid final result, i.e., the root constructed on the invalid leaf node(s). In Figure \ref{fig:ZSPA}, we provide ZSPA that efficiently generates $b$ vectors where each vector elements is sum to zero. 






%\begin{figure}[ht]
%\setlength{\fboxsep}{0.7pt}
%\begin{center}
%\begin{boxedminipage}{12.3cm}

%
%\begin{figure}[ht]%[!htbp]
%\setlength{\fboxsep}{1pt}
%\begin{center}
%    \begin{tcolorbox}[enhanced,width=5.5in, 
%    drop fuzzy shadow southwest,
%    colframe=black,colback=white]
%
%
%\small{
%
%\begin{enumerate}
%\item[$\bullet$]  \textit{Parties.} $\{\resizeT {\textit A}_{\resizeS {\textit  1}},..., \resizeT {\textit A}_{\resizeS {\textit  m}}\}$
%\item[$\bullet$]  \textit{Input.}  $m$: the total number of participants and a deployed smart contract's address. 
%\item[$\bullet$] \textit{Output.}  $k$: a secret key that generates $b+1$ vectors $[z_{\scriptscriptstyle 0,1},...,z_{\scriptscriptstyle 1,m}],...,[z_{\scriptscriptstyle b,1},...,z_{\scriptscriptstyle b,m}]$ of pseudorandom values, $h$: hash of the key,  $g$: a Merkle tree's root, and a vector of signed messages. 
%
%
%%, such that the sum of each vector's elements equals zero: $\sum\limits^{\scriptscriptstyle m}_{\scriptscriptstyle j=1}z_{\scriptscriptstyle i,j}=0$. 
%
%
%\item All participants run a coin tossing protocol to agree on a key $k$  of $\mathtt{PRF}$.
%\item\label{ZSPA:val-gen} One of the parties:  
%\begin{enumerate}
%
%\item for every $i$ (where $0\leq i \leq b$), generates $m$ pseudorandom values as follows. 
%%
% $$\forall j, 1\leq j \leq m-1: z_{\scriptscriptstyle i,j}=\mathtt{PRF}(k,i||j), \hspace{5mm} z_{\scriptscriptstyle i,m}=-\sum\limits^{\scriptscriptstyle m-1}_{\scriptscriptstyle j=1}z_{\scriptscriptstyle i,j}$$
%%
%\item   constructs a Merkel tree on top of all pseudorandom values,  $\mathtt{MT.genTree}(z_{\scriptscriptstyle 0,1},...,z_{\scriptscriptstyle b,m})\rightarrow g$. 
%
%\item  sends the Merkel tree's root: $g$,   and the key's hash: $q=\mathtt {H}(k)$ to the smart contract. 
%
%\end{enumerate}
%
%\item\label{ZSPA:verify} The rest of parties (given $k_{\scriptscriptstyle 1}, k_{\scriptscriptstyle 2}$) check if, all $z_{\scriptscriptstyle i,j}$ values, the root $g$ and key's hash have been correctly generated (by redoing  step \ref{ZSPA:val-gen}). If the checks pass, each party sends a singed ``approved'' message to the  contract. Otherwise, it aborts. 
%
%
% \end{enumerate}
%}
% \end{tcolorbox}
%\end{center}
%\caption{Zero-sum Pseudorandom Values Agreement (ZSPA) Protocol} 
%\label{fig:ZSPA}
%\end{figure}
%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{figure}[ht]
%\setlength{\fboxsep}{0.7pt}
%\begin{center}
%\begin{boxedminipage}{12.3cm}
%
%\small{
%
%\begin{enumerate}
%\item[$\bullet$]  \textit{Parties:} $\{\resizeT {\textit A}_{\resizeS {\textit  1}},..., \resizeT {\textit A}_{\resizeS {\textit  m}}\}$
%\item[$\bullet$]  \textit{Public Parameters and Functions:} A pseudorandom function: $\mathtt{PRF}$, a deployed smart contract, and total number of participants: $m$. 
%\item[$\bullet$] \textit{Output}:  All parties agree on $b+1$ vectors $[z_{\scriptscriptstyle 0,1},...,z_{\scriptscriptstyle 1,m}],...,[z_{\scriptscriptstyle b,1},...,z_{\scriptscriptstyle b,m}]$, of pseudorandom values, such that the sum of each vector's elements equals zero: $\sum\limits^{\scriptscriptstyle m}_{\scriptscriptstyle j=1}z_{\scriptscriptstyle i,j}=0$
%
%
%\item All participants run a coin tossing protocol to agree on two keys $k_{\scriptscriptstyle 1}$ and $k_{\scriptscriptstyle 2}$ of $\mathtt{PRF}$.
%\item\label{ZSPA:val-gen} One of the parties:  
%\begin{enumerate}
%
%\item For every $i$, computes $m$ pseudorandom values: $\forall j, 1\leq j \leq m-1: z_{\scriptscriptstyle i,j}=\mathtt{PRF}(k_{\scriptscriptstyle 1},i||j)$ and sets $z_{\scriptscriptstyle i,m}=-\sum\limits^{\scriptscriptstyle m-1}_{\scriptscriptstyle j=1}z_{\scriptscriptstyle i,j}$, where $0\leq i \leq b$
%
%\item   commits to every $z_{\scriptscriptstyle i,j}$  as follows: $\mathtt{a}_{\scriptscriptstyle i,j}=\mathtt{Com}(z_{\scriptscriptstyle i,j}, q_{\scriptscriptstyle i,j})$, where the randomness of the commitment is computed as: $ q_{\scriptscriptstyle i,j}=\mathtt{PRF}(k_{\scriptscriptstyle 2},i||j)$ and  $1\leq j \leq m$.
%
%\item   constructs a Merkel tree on top of the committed values: $\mathtt{MT}(\mathtt{a}_{\scriptscriptstyle 0,1},...,\mathtt{a}_{\scriptscriptstyle b,m})\rightarrow g$ 
%
%\item  sends the Merkel tree's root: $g$,   and the keys' hashes: $\mathtt {H}(k_{\scriptscriptstyle 1})$ and $ \mathtt {H}(k_{\scriptscriptstyle 2})$, to the contract. 
%
%\end{enumerate}
%
%\item\label{ZSPA:verify} The rest of parties (given $k_{\scriptscriptstyle 1}, k_{\scriptscriptstyle 2}$) check if, all $z_{\scriptscriptstyle i,j}$ values, the root $g$ and keys' hashes have been correctly generated (by redoing  step \ref{ZSPA:val-gen}). If passed, each party sends a singed ``approved'' message to the  contract. Otherwise, it aborts. 
%
%
% \end{enumerate}
%}
%\end{boxedminipage}
%\end{center}
%\caption{Zero-sum Pseudorandom Values Agreement ($\mathtt{ZSPA}$) Protocol} 
%\label{fig:ZSPA}
%\end{figure}


